<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Eli W. Hunter">
    <meta name="description" content="NC State Student">
    

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CSC 230: C &amp; Software Tools"/>
<meta name="twitter:description" content="Coding Style We use Javadoc-style Doxygen comments.
We avoid magic numbers, instead using constants via preprocessor directives (#define VALUE_NAME &lt;VALUE&gt;).
Indent with soft tabs (i.e. spaces). One statement per line. End all lines with \n.
Avoid global variables because they&#39;re really unsafe and it&#39;s hard to track their modification.
Compilation Java uses cross-platform bytecode that the JVM will use on runtime to produce and run machine code. The JVM either uses a bytecode interpreter or Just-In-Time (JIT) compilation."/>

    <meta property="og:title" content="CSC 230: C &amp; Software Tools" />
<meta property="og:description" content="Coding Style We use Javadoc-style Doxygen comments.
We avoid magic numbers, instead using constants via preprocessor directives (#define VALUE_NAME &lt;VALUE&gt;).
Indent with soft tabs (i.e. spaces). One statement per line. End all lines with \n.
Avoid global variables because they&#39;re really unsafe and it&#39;s hard to track their modification.
Compilation Java uses cross-platform bytecode that the JVM will use on runtime to produce and run machine code. The JVM either uses a bytecode interpreter or Just-In-Time (JIT) compilation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/notes/csc230/" />



    
      <base href="/notes/csc230/">
    
    <title>
  Eli W. Hunter · CSC 230: C &amp; Software Tools
</title>

    
      <link rel="canonical" href="/notes/csc230/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.83a2010dac9f59f943b3004cd6c4f230507ad036da635d3621401d42ec4e2835.css" integrity="sha256-g6IBDayfWflDswBM1sTyMFB60DbaY102IUAdQuxOKDU=" crossorigin="anonymous" media="screen" />
      
    

    

    

    
      
      
        
        <link rel="stylesheet" href="/scss/notes.min.18fab4627e52eeea39fef1958d59d56dc7b8e9ba59e5111c7b1a4f634aec4831.css" integrity="sha256-GPq0Yn5S7uo5/vGVjVnVbce46bpZ5REcexpPY0rsSDE=" crossorigin="anonymous" media="screen" />
      
    

    <link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.61.0" />
  </head>

  
  
    
  
  <body class="colorscheme-auto">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      Eli W. Hunter
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/notes/">Notes</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/resume.pdf">Résumé</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
<section class="container post">
  <article>
    <header>
      <div class="post-title">
        <h1 class="title">CSC 230: C &amp; Software Tools</h1>
      </div>
      <div class="post-meta">
        <div class="date">
          <span class="posted-on">
            <i class="fas fa-calendar"></i>
            Fall 2019
          </span>
          <span>
            <i class="fas fa-user"></i>
            Dr. Susan Balik
          </span>
        </div>
      </div>
      
      
        <div class="post-toc">
          <h1 class="toc-title">Table of Contents</h1>
          <nav id="TableOfContents">
  <ul>
    <li><a href="#coding-style">Coding Style</a></li>
    <li><a href="#compilation">Compilation</a></li>
    <li><a href="#revision-control">Revision Control</a></li>
    <li><a href="#debugging">Debugging</a></li>
    <li><a href="#types-and-variables">Types and Variables</a></li>
    <li><a href="#standard-library">Standard Library</a></li>
    <li><a href="#memory-segmentation">Memory Segmentation</a></li>
    <li><a href="#pointers">Pointers</a></li>
    <li><a href="#dynamic-allocation">Dynamic Allocation</a></li>
    <li><a href="#managing-larger-projects">Managing Larger Projects</a></li>
    <li><a href="#goto">Goto</a></li>
    <li><a href="#side-effects">Side Effects</a></li>
    <li><a href="#procedure-evaluation">Procedure Evaluation</a></li>
    <li><a href="#arrays">Arrays</a></li>
    <li><a href="#function-pointers">Function Pointers</a></li>
    <li><a href="#struct">Struct</a></li>
    <li><a href="#typedef">Typedef</a></li>
    <li><a href="#data-structures">Data Structures</a></li>
    <li><a href="#advanced-object-orientation">Advanced Object Orientation</a></li>
    <li><a href="#handling-binary-data">Handling Binary Data</a></li>
    <li><a href="#object-oriented--component-design">Object Oriented / Component Design</a></li>
    <li><a href="#security--safety">Security & Safety</a></li>
    <li><a href="#encryption">Encryption</a></li>
    <li><a href="#enums">Enums</a></li>
    <li><a href="#unions">Unions</a></li>
    <li><a href="#odd-keywords">Odd Keywords</a></li>
    <li><a href="#testing--profiling">Testing & Profiling</a></li>
    <li><a href="#c">C++</a></li>
  </ul>
</nav>
        </div>
      
    </header>

    <div class="note">
      <h1 id="coding-style">Coding Style</h1>
<p>We use Javadoc-style <a href="http://doxygen.nl/">Doxygen</a> comments.</p>
<p>We avoid magic numbers, instead using constants via preprocessor directives
(<code>#define VALUE_NAME &lt;VALUE&gt;</code>).</p>
<p>Indent with soft tabs (i.e. spaces). One statement per line. End all lines with
<code>\n</code>.</p>
<p>Avoid global variables because they're really unsafe and it's hard to track
their modification.</p>
<h1 id="compilation">Compilation</h1>
<p>Java uses cross-platform bytecode that the JVM will use on runtime to
produce and run machine code. The JVM either uses a bytecode interpreter or
Just-In-Time (JIT) compilation. JIT is faster.</p>
<p>C directly generates machine code.</p>
<ul>
<li>Java
<ul>
<li>Cross platform bytecode binaries.</li>
<li>Can be easier to debug.</li>
</ul>
</li>
<li>C
<ul>
<li>Produces faster code.</li>
</ul>
</li>
</ul>
<h2 id="steps">Steps</h2>
<p>The parts are split into a frontend and backend. Frontends deal with the
language specifics. Backends deal with the architecture specifics. The middle
speaks a standard language.</p>
<p>This let's the hardest parts (optimization) be handled in a repeatable way for
different languages and architectures.</p>
<ul>
<li>Frontend: preprocessing, lexical analysis, parsing, assembler.</li>
<li>Backend: code generation, assembler.</li>
</ul>
<h2 id="preprocessing">Preprocessing</h2>
<p>Goes in and processes all the preprocessor directives (lines that start with
<code>#</code>) in the source code.</p>
<p>There are a bunch of different kinds of preprocessor directives:</p>
<ul>
<li><code>#define MACRO_NAME(ARGS) MACRO_VALUE</code>: Defines a macro with the given name,
which textually expands to the macro value, textually replacing the given
arguments.</li>
<li><code>#include &lt;filename&gt;</code>: Copies the given filename in place of this. This first
looks into the system directories and then looks in the current directory.</li>
<li><code>#include &quot;filename&quot;</code>: Does the same thing as the above, but looks in the
current directory first and then looks into the system directories.</li>
</ul>
<h3 id="macros">Macros</h3>
<p>C preprocessor macros are textual and unhygienic (meaning they can have name
collisions). Because of this, you really should only use them for defining
constants.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Defining simple constants. Make sure you don&#39;t put simple constants!
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">define SIZE 5</span><span style="color:#ff79c6">
</span></code></pre></div><p>Macros do allow you to define multi-line functions. These functions are
pass-by-name, where they have access to whatever names were present in the code
at the time. (Make sure that you aren't using global variables here. Because of
variable shadowing, this may not do what you expect.) Also, because of operator
precedence, we should surround all variables in parentheses and the entire
macro value in parentheses, if we're using multiple operators.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Bad behavior!
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">define TIMES_TWO(x) x * 2</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>TIMES_TWO(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>); <span style="color:#6272a4">// results in 1 + 1 * 2 = 3, not (1 + 1) * 2 = 4, as we&#39;d expect
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// Better behavior
</span></code></pre></div><p>However, macros do allow for (very limited, very messy) generic programming.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Generic Programming with Macros
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// Relying on operators working with types
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">define MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#6272a4">// Taking an explicit type
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">define SWAP(x, y, type) { \</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">  type tmp = x; \</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">  x = y; \</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">  y = tmp; \</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">}</span><span style="color:#ff79c6">
</span></code></pre></div><p>You can also control macro expansion using</p>
<ul>
<li><code>#x</code>: Puts quotes around the value <code>x</code> of the given argument. Useful for
debugging sometimes.</li>
<li><code>x ## y</code>: Puts quotes around the value <code>x</code> and <code>y</code>. Due to implicit string
literal concatenation, these concatenate each other.</li>
</ul>
<h3 id="include-guard">Include Guard</h3>
<h2 id="lexical-analysis">Lexical Analysis</h2>
<p>Converts source code into tokens.</p>
<p>The C scanner / lexical analyzer is a maximal muncher. This means it goes as
far as it can with its first guess whenever there is ambiguity.</p>
<h2 id="parsing">Parsing</h2>
<p>Converts the string of tokens into an Abstract Syntax Tree (AST).</p>
<h2 id="optimization">Optimization</h2>
<p>Analyzes, modifies, and makes the AST more efficient. This can run few to many
times, depending on the compilation parameters.</p>
<h2 id="code-generation">Code Generation</h2>
<p>Converts the AST into a specific architecture's assembly instructions.</p>
<h2 id="assembler">Assembler</h2>
<p>A specific architecture's assembler goes in and converts the assembly to
machine code.</p>
<h1 id="revision-control">Revision Control</h1>
<p>Why do we need revision control? To coordinate work, allow faster conflict
resolution, allow people to work on the same file at the same time, etc. Here's
an example of revision control systems.</p>
<ul>
<li>SCCS (Source Code Control System, 1972): Centralized</li>
<li>RCS (Revision Control System, 1982): Centralized</li>
<li>CVS (Concurrent Versioning System, 1990): Centralized</li>
<li>SVN (Subversion, 2000): Centralized</li>
<li>git (2005): Decentralized</li>
</ul>
<p>Centralized version control has a single, authoritative server/repo. Everyone
who checks out from the server just copies the files, with no local repo.</p>
<p>Decentralized version control means everyone has a clone of the server.
Officially, there is no authoritative copy (although there is an agreed one).</p>
<h1 id="debugging">Debugging</h1>
<ul>
<li>GNU Debugger (<code>gdb</code>): A symbolic debugger for your program.</li>
<li>Valgrind: A dynamic analysis checker, ensuring that memory is properly
allocated, initialized, and freed.</li>
</ul>
<p>We use the GNU Debugger (<code>gdb</code>), for debugging. The GNU Debugger is a symbolic
debugger, meaning you get to see and interact with the symbols associated with
the memory addresses.</p>
<p>Since compilers normally don't store symbol information and other debugging
info, you have to add that using the <code>-g</code> flag.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ gcc -Wall -std<span style="color:#ff79c6">=</span>c99 -g filename.c -o filename
$ gdb ./filename <span style="color:#ff79c6">[</span>args...<span style="color:#ff79c6">]</span>
</code></pre></div><h2 id="gdb-commands">GDB Commands</h2>
<p>These all have shortcuts and you can find more by running <code>help</code> in <code>gdb</code>.</p>
<ul>
<li><code>break [procedureName]</code>: Create breakpoint on procedure name.</li>
<li><code>break [lineNumber]</code>: Create breakpoint on line number.</li>
<li><code>delete [breakpointNumber]</code>: Delete breakpoint.</li>
<li><code>condition [breakpointNumber] [condition]</code>: Make breakpoint conditional on
condition.</li>
<li><code>set variable n = 25</code>: Change the value of a variable.</li>
</ul>
<h3 id="inspecting-code">Inspecting Code</h3>
<ul>
<li><code>print [expression]</code>: Print the value of the expression.</li>
<li><code>backtrace</code>: Displace the stack trace.</li>
<li><code>up</code>: Look at the variable values in the above stack trace (i.e. child).</li>
<li><code>down</code>: Look at the variable values in the below stack trace (i.e. parent).</li>
<li><code>list</code>: Look at source code surrounding current statement.</li>
<li><code>list [procedureName]</code>: Look at code for procedure.</li>
</ul>
<h3 id="executing-code">Executing Code</h3>
<ul>
<li><code>run</code>: Go! You can also do redirection.</li>
<li><code>continue</code>: Go until next breakpoint.</li>
<li><code>next</code>: Go to next statement.</li>
<li><code>step</code>: Go to next statement, going into function calls.</li>
<li><code>until [lineNumber]</code>: Run until you hit the line number.</li>
<li><code>finish</code>: Go until the function exists.</li>
</ul>
<h2 id="asserth"><code>assert.h</code></h2>
<p><strong>Note:</strong> It is recommended to disable assertions in production code (by
defining <code>NDEBUG</code>). It is recommended to not disable them during debugging and
testing though. Normally, you write <code>assert</code> statements in your procedures to
validate input.</p>
<p>C allows you to perform easy sanity checks using <code>assert.h</code> (such as bound
checks). This provides an <code>assert</code> procedure, that asserts that some given
boolean is true, otherwise is crashes the program and prints out information
about the issue.</p>
<p>It is recommended that you include assert statements to catch errors during
development and document assumptions. They can be trivially disabled during
production compilation.</p>
<h3 id="examples">Examples</h3>
<p>A simple procedure with <code>assert</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&lt;assert.h&gt;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>
<span style="color:#8be9fd">int</span> <span style="color:#50fa7b">f</span>(<span style="color:#8be9fd">int</span> a, <span style="color:#8be9fd">int</span> b)
{
  assert( a <span style="color:#ff79c6">!</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">&amp;</span> b <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span> );
  ...
}
</code></pre></div><p>Compiling.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#6272a4"># No debugging</span>
$ gcc -DNDEBUG -std<span style="color:#ff79c6">=</span>c99 -Wall ...
<span style="color:#6272a4"># With debugging</span>
$ gcc -g -std<span style="color:#ff79c6">=</span>c99 -Wall ...
</code></pre></div><h2 id="valgrind">Valgrind</h2>
<p>Valgrind is a dynamic error detection tool. It runs your code in a VM using JIT
compilation. It adds several error-checking instructions in your code. It can
also use <em>symbol information</em>, so you should generally use <code>-g</code> to compile with
symbolic debugging information.</p>
<p><strong>Note:</strong> This causes significant overhead. 10-100x.</p>
<p>Valgrind has several tools, but you can only run one at a time.</p>
<p>By default, it uses <code>memcheck</code>, which checks for misuse of heap-allocated
memory, out of bounds memory access for heap-allocated memory (not stack or
static), and leaked memory (with <code>--leak-check=full</code>). There are options for
this, such as <code>--track-fds=yes</code> that tracks file descriptors.</p>
<p>There's an experimental tool called <code>exp-sgcheck</code> that does <code>s</code>tatic and
<code>g</code>lobal bounds checking. It uses heuristics and may return false positives and
false negatives.</p>
<p><strong>Note:</strong> Valgrind produces a lot of output. Most of it useful.</p>
<h3 id="examples-1">Examples</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#6272a4"># Compile your program with symbolic information</span>
$ gcc -g -std<span style="color:#ff79c6">=</span>c99 –Wall program.c -o program

<span style="color:#6272a4"># General usage</span>
$ valgrind valgrind-options ./program program-options

<span style="color:#6272a4"># Example usage (--tool=memcheck is unnecessary)</span>
$ valgrind --tool<span style="color:#ff79c6">=</span>memcheck --leak-check<span style="color:#ff79c6">=</span>full ./program
</code></pre></div><h2 id="cppcheck">CPPCheck</h2>
<p>CPPCheck (<code>cppcheck</code>) is a static analysis tool. It's not great, but it can
catch un-obfuscated issues bound access.</p>
<h1 id="types-and-variables">Types and Variables</h1>
<h2 id="standardfundamental-types">Standard/Fundamental Types</h2>
<p>C has a fairly rich standard library of types, but it doesn't mandate much
about actual sizes. That means the size is <em>platform dependent</em>. See <code>limits.h</code>
for your platform's sizes.</p>
<p>We have integral values. For every type, there is a <code>signed</code> and <code>unsigned</code>
version. By default things are <code>signed</code>.</p>
<ul>
<li><code>long long</code>: At least 64 bits or as large as <code>long</code>.</li>
<li><code>long</code>: At least 64 bits or as large as <code>int</code>.</li>
<li><code>int</code>: At least 32 bits or as large as <code>short</code>.</li>
<li><code>short</code>: At least 16 bits or as large as <code>char</code>.</li>
<li><code>char</code>: At least 8 bits.</li>
</ul>
<p>We have real values.</p>
<ul>
<li><code>long double</code>: At least as large as <code>double</code>.</li>
<li><code>double</code>: Double precision float.</li>
<li><code>float</code>: Single precision float.</li>
</ul>
<p>There's also a few &ldquo;fake&rdquo; or odd types.</p>
<ul>
<li><code>_Bool</code>: A &ldquo;fake&rdquo; type that is an integer underneath. Really, <code>0</code> is <code>false</code>
(both integer and float) and anything else is <code>true</code>.
<ul>
<li>This has a strange name to preserve backwards compatibility.</li>
<li>If you include <code>stdbool.h</code>, you get the nice preprocessor constants of
<code>bool =&gt; _Bool</code>, <code>true =&gt; 1</code>, and <code>false =&gt; 0</code>.</li>
</ul>
</li>
<li><code>void</code>: Nothing and anything.</li>
</ul>
<h2 id="making-variables">Making Variables</h2>
<p>Variables have</p>
<ul>
<li>Name: How the variable is accessed. Must be a legal identifier.</li>
<li>Type: How the contents of the variable's memory is organized (and thought
about).</li>
<li>Scope: Where the variable can be used.</li>
<li>Storage Class: How the variable is stored and initialized.</li>
</ul>
<p>C allows for <strong>variable shadowing</strong>. This just means you can declare a new
variable of the same name in a narrower scope and you can only access the newer
variable with the same name. This should generally be avoided.</p>
<h2 id="literals">Literals</h2>
<p>Literals are different from variables because they don't have a name, type,
scope, or storage class (well, string literals have <code>static</code> storage).</p>
<p>The C compiler infers/coerces your literal to the type required.</p>
<p>Adjacent string literals are implicitly concatenated. This is most useful for
multi-line strings.</p>
<h3 id="integers">Integers</h3>
<p>The compiler infers their type type by treating the number as the smallest type
required to store the literal and then using its type promotion semantics.</p>
<p>You can specify the type of integers by appending</p>
<ul>
<li><code>U</code> for unsigned.</li>
<li><code>L</code> for long.</li>
<li><code>LL</code> for long long.</li>
</ul>
<p>Integer literals that start with <code>0</code> are octal. Integer literals that start
with <code>0x</code> are hexadecimal.</p>
<h3 id="floats">Floats</h3>
<p>Floats are computerized scientific notation. They are split into a sign bit,
mantissa, and exponent.</p>
<ul>
<li>Sign Bit: A single bit at the beginning of a list</li>
<li>Mantissa: The value part of the number.</li>
<li>Exponent: Determines the order of magnitude.</li>
</ul>
<p>Since, scientific notation mandates that the number before the decimal not be
zero and binary is only 1s and 0s, we always know that floats start with a 0.</p>
<p>Unlike integers, floats cannot have overflow. However, they can have underflow.
Since floats represent continuous fields as discrete values using &ldquo;scientific
notation&rdquo;, floats far from zero are fairly imprecise. This means that you can
get &ldquo;stuck&rdquo; at certain high values because you cannot &ldquo;jump past&rdquo; the number,
since they're so far apart.</p>
<h3 id="strings">Strings</h3>
<p>C is weird and annoying. A string is really just a null-terminated array of
characters (i.e. unsigned bytes). Null terminated? Yeah, that just means that a
<code>\0</code> ends the array.</p>
<p>They can be encoded in any way but normally using ASCII or UTF-8 (or UTF-16 if
you're Windows and hate yourself). Here we will use ASCII encoded strings.</p>
<p>Since strings are just arrays, you can iterate over them like arrays. However,
you can also iterate over them using pointers until you reach a null character!
IMO, this is more clear because it is more like a for each loop.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>c <span style="color:#ff79c6">=</span> string; <span style="color:#ff79c6">*</span>c <span style="color:#ff79c6">!</span><span style="color:#ff79c6">=</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\0</span><span style="color:#f1fa8c">&#39;</span>; c<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span>) {
  <span style="color:#6272a4">// Using pointers. Means you can avoid array syntax.
</span><span style="color:#6272a4"></span>}
<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; string[i]; i<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span>) {
  <span style="color:#6272a4">// Using arrays, along with the null terminator (0) being falsey.
</span><span style="color:#6272a4"></span>}
</code></pre></div><h2 id="type-promotion">Type Promotion</h2>
<p>In C, some integers are considered &ldquo;more specific&rdquo;/wider while others are &ldquo;less
specific&rdquo;/narrower. Narrower numbers are automatically casted to the wider numbers.
This is called type promotion and it follows the following graph.</p>
<dl>
<dt>Type Promotion Graph</dt>
<dd><img src="type_promotion.png" alt="Type Promotion Graph"></dd>
</dl>
<p>Integers specifically have the concept of rank, which is basically the same
thing as narrow vs wide. A <code>int</code> is a higher rank than a <code>short</code>. A <code>int</code> is
the same rank as a <code>int</code>.</p>
<p>The following rules apply in the following order.</p>
<ol>
<li>A lower rank integer of a certain sign-ness is promoted to a higher rank
integer of the same sign-ness.</li>
<li>A lower rank unsigned integer is promoted to a higher rank signed integer
(since they can fit). This occurs automatically when a same-rank signed and
unsigned integer interact; they both get promoted to a higher rank signed.</li>
<li>A same rank signed integer becomes a same rank unsigned integer if you can't
promote them both.</li>
</ol>
<p>These semantics are summed up by the following flow charts.</p>
<dl>
<dt>Integer Rank 1</dt>
<dd><img src="integer_rank1.png" alt="Integer Rank 1"></dd>
<dt>Integer Rank 2</dt>
<dd><img src="integer_rank2.png" alt="Integer Rank 2"></dd>
<dt>Integer Rank 3</dt>
<dd><img src="integer_rank3.png" alt="Integer Rank 3"></dd>
</dl>
<h2 id="operators">Operators</h2>
<p>There's bunch of friends we get from Java, so I'll only cover the new ones.</p>
<p>The <code>sizeof &lt;TYPE&gt;</code> operator returns the number of bytes in a type. For
integers, this is the special <code>size_t</code> type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> bro <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">sizeof</span>( <span style="color:#8be9fd">int</span> );
</code></pre></div><p>Since C has type promotion, you don't always need casting, but it helps the
compiler and allows you to shrink types explicitly. You can always explicitly
throw away values by casting to <code>void</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Convert long to short
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">short</span> a <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">short</span>) <span style="color:#bd93f9">123L</span>;
<span style="color:#6272a4">// Explicitly throw away return value
</span><span style="color:#6272a4"></span>(<span style="color:#8be9fd">void</span>) getchr();
</code></pre></div><h1 id="standard-library">Standard Library</h1>
<p>A great resource is <a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a>.</p>
<h2 id="stdioh"><code>stdio.h</code></h2>
<p>C uses <strong>streams</strong> for IO. A stream is just a stream of characters/bytes and is
an abstraction of all input. There all three standard streams:</p>
<ul>
<li>
<p><code>stdout</code> (0): Normal, expected output.</p>
</li>
<li>
<p><code>stderr</code> (2): Exceptional output.</p>
</li>
<li>
<p><code>stdin</code> (1): Normal input.</p>
</li>
<li>
<p><code>int getchar()</code>: Reads a single character from stdin as an int.</p>
</li>
<li>
<p><code>void putchr(int)</code>: Outputs a single character into stdout.</p>
</li>
<li>
<p><code>int printf(const *char, ...)</code>: Outputs a string into stdout using the format
string followed by the arguments/values for the format specifers in the
format string.</p>
</li>
<li>
<p><code>int scanf(const *char, ...)</code>: Outputs format string to stdout, pausing
for input whenever it reaches an input specifier. It then tries to parse the
input correctly and put it into the corresponding pointer in the
arguments after the format string. The pointers are used in the order given.
Returns number of successfully parsed values. <strong>This fails fast and matches
greedily.</strong></p>
</li>
</ul>
<h3 id="file-io">File IO</h3>
<p><code>stdio.h</code> includes opaque <code>FILE</code> structs which are used to interact with file
streams. These streams are only interacted with through procedures provided by
<code>stdio.h</code>. The earlier standard streams are also provided as preprocessor
macros that expand to specific <code>FILE</code> structs.</p>
<p>Most OSes limit the number of files a process can have. This is both practical
and acts as a small stopgap for malpractice. In Linux, we can have 1024 open
files (meaning Linux gives us 10 bits). In practice we can only have 1021
because of <code>stdout</code>, <code>stderr</code>, and <code>stdin</code>.</p>
<ul>
<li><code>FILE *fopen(const char *filename, const char *mode)</code>: Returns a file pointer
to the desired file.</li>
<li><code>int fclose(FILE *filestream)</code>: Closes the given file stream. This is
important because file streams use buffering (aka caching) and the OS limits
the number of files we can have.</li>
<li><code>int feof(FILE *stream)</code>: Returns true if <code>EOF</code> has been read by any file IO
class. This is set by the reading functions.
<ul>
<li><strong>You should generally not use this because it is error prone</strong>. Really,
just think about what's happening.</li>
</ul>
</li>
<li><code>int ferror(FILE *stream)</code>: Returns true if any operation on the file
failed/errored. This is error is set whenever any operation fails. No future
successful operations will overwrite this error flag.</li>
<li><code>void clearerr(FILE *stream)</code>: Clears the error flag from the file. Must be
called manually, otherwise errors will never be cleared.</li>
<li><code>int fprintf(FILE *filestream, const char *format, ...)</code>: Like <code>printf</code>,
except it prints into the given file stream.</li>
<li><code>int fscanf(FILE *filestream, const char *format, ...)</code>: Like <code>scanf</code>, except
it scans from the given file stream.</li>
<li><code>int fgetc(FILE *stream)</code>: Like <code>getchar</code> but reads from the given file.</li>
<li><code>int getc(FILE *stream)</code>: Same as <code>getc</code>, but may be a macro.</li>
<li><code>int ungetc(int c, FILE *stream)</code>: Puts character <code>c</code> back onto the stream
and clears the EOF flag. This works even for stdin.
<ul>
<li>You can't write EOF back.</li>
<li>This works because streams perform buffering. You can just write some
values back to the buffer or scroll back the buffer one.</li>
</ul>
</li>
<li><code>int put(FILE *stream)</code>: Same as <code>putc</code>, but may be a macro.</li>
<li><code>int fflush(FILE *stream)</code>: Flushes the buffer for the given file. All file
IO in C is buffered by default. Returns <code>EOF</code> if failure and sets the error
on the stream.
<ul>
<li>stdout normally flushes with new lines.</li>
</ul>
</li>
<li><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code>: Read
<code>nmemb</code> members, each with size <code>size</code> into the memory at <code>ptr</code> from file
<code>stream</code>. Returns number of bytes read.</li>
<li><code>size_t fwrite(void *ptr, size_t size, size_t nmemb, FILE *stream)</code>: Same as
<code>fread</code> except it writes to the file stream rather than reading.</li>
<li><code>int rewind(FILE *stream )</code>: Restart the file pointer from the start.
<ul>
<li>If you're using this, you're probably doing something you shouldn't.</li>
</ul>
</li>
<li><code>int fseek(FILE *stream, long offset, int whence)</code>: Seek to anywhere in the
file. Offset can be positive or negative, depending on <code>whence</code>.
<ul>
<li><code>whence</code> tells you with respect to what you're seeking. It can be:
<ul>
<li><code>SEEK_SET</code>: Relative to start.</li>
<li><code>SEEK_CUR</code>: Relative to current position.</li>
<li><code>SEEK_END</code>: Relative to end of file.</li>
</ul>
</li>
<li>This is best for <strong>binary data</strong> because text has inconsistent offsets
cross platform, meaning it might &ldquo;lie&rdquo; to you.</li>
</ul>
</li>
<li><code>long ftell(FILE *stream)</code>: Return current position in file from beginning.</li>
<li><code>int remove(const char *pathname)</code>: Remove file.</li>
<li><code>int rename(const char *old, const char *new)</code>: Rename file. Return EOF on
failure.</li>
<li><code>FILE *mktemp()</code>: Create temporary file.</li>
</ul>
<h4 id="buffered-file-io">Buffered File IO</h4>
<p>Calls to the OS (required for writing/reading files) are costly, so C
caches/buffers our desired input and output. When we fill up the buffer, we
preform a single call to the OS. This is one reason why closing files is
important. Closing a file flushes the buffer by preforming a call to the OS.</p>
<h4 id="binary-file-io">Binary File IO</h4>
<p>You can open files in text mode or binary mode in C. On the common platform,
they happen to be the same but this isn't generally true.</p>
<p>Text mode tries to hide some details of the file, such line termination.
Meanwhile, binary mode gives you literally the bytes in the file.</p>
<h4 id="block-file-io">Block File IO</h4>
<p>Sometimes, reading character by character isn't very useful. We can instead
read arbitrary blocks of binary data into any part of our program. This is
useful for serialization and deserialization of arbitrary data types.</p>
<p>This can also provide a performance advantage.</p>
<h4 id="file-open-modes">File Open Modes</h4>
<ul>
<li><code>r</code>: Read</li>
<li><code>rb</code>: Read binary</li>
<li><code>wb</code>: Write binary</li>
<li><code>w</code>: Write</li>
<li><code>r+</code>: Read and write</li>
<li><code>a</code>: Append</li>
</ul>
<h2 id="stringh"><code>string.h</code></h2>
<p><code>string.h</code> is a standard library header file that provides useful procedures
for using null-terminated strings:</p>
<ul>
<li><code>int strlen(const char*)</code>: Get the number of characters in the string
(excluding the null terminator).
<ul>
<li><strong>Note:</strong> This should not be used for iteration, because it requires
looping over the array multiple times.</li>
</ul>
</li>
<li><code>char *strcpy(char *dest, const char* src)</code>: Copies the contents of <code>src</code> to
<code>dest</code>, up to the first null character in <code>src</code>.
<ul>
<li>It is generally recommended not to use this.</li>
<li><strong>Note:</strong> This does not check for <code>dest</code> being too small (because it
can't), so you must assure this yourself (or use <code>strncpy</code>).</li>
</ul>
</li>
<li><code>char *strncpy(char *dest, const char* src, int n)</code>: Copies the contents of
<code>src</code> to <code>dest</code>, up to the first null character in <code>src</code> or the <code>n</code>th
character in <code>src</code>, whichever comes first. This prevents overwriting memory.
<ul>
<li>If <code>src</code> is smaller than <code>n</code>, <code>strncpy</code> pads the rest of the characters
with zero.</li>
<li>This does not put a null character at the end of the string if it runs out
of space. To guarantee this, always <em>set the last the last character in the
buffer to null</em>.</li>
</ul>
</li>
<li><code>char *strcat(char *dest, const char *src)</code>: Appends the characters from
<code>src</code> to <code>dest</code> (overwriting and replacing the null character on <code>dest</code>).
This may write outside of the buffer and will not always put a null character
on the end.</li>
<li><code>char *strncat(char *dest, const char *src, size_t n)</code>: Appends the
characters from <code>src</code> to <code>dest</code> (overwriting and replacing the null character
on <code>dest</code>), where the max length of <code>dest</code> is <code>n</code>. If appending the
characters to <code>dest</code> would make it be longer than <code>n</code>, it stops and puts a
null character at the end.
<ul>
<li>This <strong>always</strong> puts a null character at the end.</li>
</ul>
</li>
<li><code>int strcmp(const char *s1, const char *s2)</code>: Compares <code>s1</code> and <code>s2</code>
lexicographically.
<ul>
<li>Returns: <code>&lt; 0</code> when <code>s1 &lt; s2</code>. <code>0</code> when <code>s1 == s2</code>. <code>&gt; 0</code> when <code>s1 &gt; s2</code>.</li>
</ul>
</li>
<li><code>int strncmp(const char *s1, const char *s2, size_t n)</code>: Compares <code>s1</code> and
<code>s2</code> lexicographically, reading at most <code>n</code> characters from both strings.
<ul>
<li>This is only really useful when you don't have null terminate strings or
you only want to compare the first few elements.</li>
</ul>
</li>
<li><code>int sscanf(const char *str, const char *format, ...)</code>: Like <code>scanf</code> except
reads from <code>str</code> as input. Unlike <code>scanf</code> and <code>fscanf</code>, this does not move
the string forward (see <code>str</code> is <code>const</code>).
<ul>
<li>Has special format specifier <code>%n</code>. This writes a <code>char *</code>, holding the
position where <code>sscanf</code> left.</li>
</ul>
</li>
<li><code>int sprintf(char *str, const char *format, ...)</code>: Like <code>printf</code> except
writes to <code>str</code>.</li>
<li><code>int snprintf(char *str, size_t size, const char *format, ...)</code>: Like
<code>sprintf</code> except it writes at most <code>size</code> bytes including the null character
to <code>str</code>. That is, <code>size</code> is the <strong>size</strong> of the string buffer.</li>
</ul>
<p>We also have the following number parsing procedures. When these fail, they
return <code>0</code>, so they are not the best way to do this. Generally, you should
prefer <code>sscanf</code>.</p>
<ul>
<li><code>int atoi(const char*)</code>: Convert ASCII to integer.</li>
<li><code>float atoi(const char*)</code>: Convert ASCII to float.</li>
<li><code>double atoi(const char*)</code>: Convert ASCII to double.</li>
<li><code>long atol(const char*)</code>: Convert ASCII to long.</li>
</ul>
<h3 id="bounds-inconsistencies">Bounds Inconsistencies</h3>
<table>
<thead>
<tr>
<th>Procedure</th>
<th><code>n</code> Behavior</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>strncpy()</code></td>
<td><code>n</code> is a number of characters to write padding with zeros if possible may not null terminate if there's no extra room.</td>
</tr>
<tr>
<td><code>strncmp()</code></td>
<td><code>n</code> is a maximum number of characters to compare will stop when we reach n, when there's a difference or either string ends (at null termination).</td>
</tr>
<tr>
<td><code>strncat()</code></td>
<td><code>n</code> is a maximum number of characters to append not counting the null terminator will always write a null terminator.</td>
</tr>
<tr>
<td><code>snprintf()</code></td>
<td><code>n</code> is a buffer capacity on the destination including the null terminator will always write a null terminator.</td>
</tr>
</tbody>
</table>
<h3 id="scanf"><code>scanf</code></h3>
<p>Since we must manually allocate strings (using character arrays) in C and we
are normally fairly lazy (very justifiably), we normally just allocate a large
enough character array for usual input. For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">char</span> someString[<span style="color:#bd93f9">100</span>]; <span style="color:#6272a4">// 100 will probably be enough, right?
</span><span style="color:#6272a4"></span>scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%s</span><span style="color:#f1fa8c">&#34;</span>, someString);
</code></pre></div><p>However, C does not bound check arrays, so <code>scanf</code> can and will write more
characters than allowed to the array, if the user inputs more than expected.
Using the previous example, if the user enters 100 characters, we'd be in
trouble (because C adds null terminators, remember?).</p>
<p>To guard against this, we can provide <code>scanf</code> a length specifier.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">char</span> someString[<span style="color:#bd93f9">100</span>];
scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%99s</span><span style="color:#f1fa8c">&#34;</span>, someString); <span style="color:#6272a4">// now we&#39;re safe!
</span></code></pre></div><p><code>scanf</code> also has some oddities with whitespace. Any whitespace in the specifier
means gobble all whitespace possible.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%d+%d</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#ff79c6">&amp;</span>a, <span style="color:#ff79c6">&amp;</span>b); <span style="color:#6272a4">// I won&#39;t match &#34;2 + 2&#34; but I will match &#34;2+2&#34;
</span><span style="color:#6272a4"></span>scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%d + %d</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#ff79c6">&amp;</span>a, <span style="color:#ff79c6">&amp;</span>b); <span style="color:#6272a4">// I will match &#34;2 + 2&#34; and &#34;2+2&#34;
</span></code></pre></div><p><code>scanf</code> also accept regex character classes, so that <code>scanf</code> only accepts
things in that character class.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%[A-Z]</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#ff79c6">&amp;</span>string); <span style="color:#6272a4">// I accept any upper case letters
</span><span style="color:#6272a4"></span>scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%[^A-Z]</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#ff79c6">&amp;</span>string); <span style="color:#6272a4">// I accept anything but upper case letters
</span></code></pre></div><p><code>scanf</code> allows us to capture but disregard things by placing a <code>*</code> after the
<code>%</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%*s %s</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#ff79c6">&amp;</span>onlyOneString);
</code></pre></div><h3 id="memory-management">Memory Management</h3>
<ul>
<li><code>void* memcpy(void* dest, const void* src, size_t count)</code>: Copies <code>count</code>
bytes from <code>src</code> to <code>dest</code>. Returns pointer to <code>dest</code>.
<ul>
<li><strong>These must not overlap</strong>.</li>
</ul>
</li>
<li><code>void *memmove(void *dest, const void *src, size_t n)</code>: Same as <code>memcpy</code>, but
uses a small internal buffer to allow for overlapping regions.</li>
<li><code>void *memset(void *s, int c, size_t n)</code>: Set <code>n</code> bytes of memory from <code>s</code> to
<code>c</code>.</li>
</ul>
<h2 id="stdlibh"><code>stdlib.h</code></h2>
<p><code>stdlib.h</code> is a giant trash can header file. Anything that doesn't fit well
anywhere else gets thrown here.</p>
<h3 id="random-numbers">Random Numbers</h3>
<p>C's random number generator is (generally) cryptographically secure, only if it
has been <strong>securely seeded</strong>. By default, C's random number generator is not
seeded <em>at all</em>.</p>
<ul>
<li><code>int rand()</code>: Generate random number from 0 to <code>RAND_MAX</code>.</li>
<li><code>RAND_MAX</code>: Maximum number returned by <code>rand</code>.</li>
<li><code>void srand(unsigned int seed)</code>: Seed <code>rand</code> using the given seed. This must
be done if you don't want the same numbers every time.
<ul>
<li>Normally, for non-cryptographic contexts, seeding it with the time is
sufficient. Do this by doing <code>void srand(time(NULL))</code>.
<ul>
<li><code>time</code> is in <code>time.h</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="environment-variables">Environment Variables</h3>
<p>C can really easily deal with environment variables (envar), but it can only do
so locally to the program.</p>
<ul>
<li><code>char *getenv(const char *varname)</code>: Get value of <code>varname</code> envar.</li>
<li><code>void setenv(const char *varname, const char *newValue, int overwrite)</code>: Set
value of <code>varname</code> envar to the new value. Doesn't overwrite if <code>overwrite</code>
is zero.</li>
</ul>
<h2 id="stdargh"><code>stdarg.h</code></h2>
<p>C implements variadic functions by providing a bunch of macros in <code>stdarg.h</code>.
In C, your variadic function <strong>must</strong> take at least one non-variadic argument.
You mark variadic arguments using <code>...</code> as the last argument. The variadic
arguments don't need to have a consistent type. C also does not store the type
or length of the variadic arguments. Instead, you must essentially treat it
like a state machine.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">printf</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>fmt, ...);
</code></pre></div><p>To use variadic arguments, we must declare a <code>va_list</code>, and then use
<code>va_start(list)</code> on it to initialize it. Then, we use <code>va_arg(list, type)</code>, to
try to extract a variable of the given type from the list. We then must call
<code>va_end(list)</code> to end the list.</p>
<pre><code>int addIntegers(int n, ...) {
  va_list ap; // for argument pointer
  va_start(ap, n);
  int total = 0;
  for (int i = 0; i &lt; n; i++) {
    total += va_arg(ap, int);
  }
  va_end(ap);
  return total;
}
</code></pre><h3 id="knowing-when-to-stop">Knowing When to Stop</h3>
<p>As mentioned earlier, C doesn't store the type or length of arguments. To
handle this, you can accept some specifiers that you can count (e.g. how
<code>printf</code> does it). You can use special final values (e.g. <code>NULL</code>). You can
accept an argument specifying the number of arguments.</p>
<p><strong>All of these are error prone and rely on you to trust the caller</strong>. Be
prepared to fail.</p>
<h2 id="setjmph"><code>setjmp.h</code></h2>
<p><code>setjmp.h</code> is a way to implement exceptions using gotos that can jump across
function boundaries (unlike C's normal <code>goto</code>s). However, it is more controlled
because you can only jump back to a single marked location, and that marked
location must handle different possibilities. It is debated on whether this is
a good thing. It can be confusing and hard to track, but you choose! Sometimes
it's good.</p>
<p>To use this, you first create a <code>jmp_buf</code> that stores <em>your program's entire
environment</em>. You then switch on a <code>setjmp</code>, where each of the cases are the
possible error codes. (Zero is the initial error code.) Then, the code in the
zero case may call <code>longjmp</code> with an int code. This then jumps back to the
<code>setjmp</code> where <code>setjmp</code> returns the given int code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// May long jump
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">readValues</span>(jmp_buf <span style="color:#ff79c6">*</span>eenv) {
  <span style="color:#8be9fd">int</span> sum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
  <span style="color:#8be9fd">int</span> m, v;
  <span style="color:#ff79c6">while</span> ((m <span style="color:#ff79c6">=</span> scanf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%d</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#ff79c6">&amp;</span>v)) <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>) {
    sum <span style="color:#ff79c6">+</span><span style="color:#ff79c6">=</span> v;
  }
  <span style="color:#ff79c6">if</span> (m <span style="color:#ff79c6">!</span><span style="color:#ff79c6">=</span> EOF) {
    longjmp(<span style="color:#ff79c6">*</span>eenv, <span style="color:#bd93f9">1</span>);
  }
  <span style="color:#ff79c6">return</span> sum;
}

<span style="color:#6272a4">// Handles long jump
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>() {
  jmp_buf eenv;
  <span style="color:#ff79c6">if</span> ( setjmp( eenv ) <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span> ) {
    readValues(<span style="color:#ff79c6">&amp;</span>eenv);
  } <span style="color:#ff79c6">else</span> {
    printf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Invalid input!</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
  }
}
</code></pre></div><h3 id="cleaning-up">Cleaning Up</h3>
<p>In some cases, we may need to do cleanup of a function that may jump up. To
handle this, we do a <code>setjmp</code> in that function and then, in the case of error,
clean up and <code>longjmp</code> again. Yes, it's annoying, but welcome to long jump.</p>
<h2 id="errnoh"><code>errno.h</code></h2>
<p>C handles errors by setting a &ldquo;global int&rdquo; called <code>errno</code> which is used to
represent a bunch of different error conditions. It's not actually a global
variable under the covers. It's a transparent preprocessor macro which has some
special handling we won't get into.</p>
<p>Most <code>errno</code>s you will ever deal with are named, documented, and supported.
Each <code>errno</code> has short messages describing then, which can be accessed through
<code>perror</code>.</p>
<ul>
<li><code>void perror(const char *s)</code>: Print an error message corresponding to the
current error. Prefix it with <code>s</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">FILE <span style="color:#ff79c6">*</span>fp <span style="color:#ff79c6">=</span> fopen(“someFile.txt”, “r”);
<span style="color:#ff79c6">if</span> (fp <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
  perror(“someFile.txt”);
  exit(<span style="color:#bd93f9">1</span>);
}
</code></pre></div><h2 id="mathh"><code>math.h</code></h2>
<p>You have to tell the linker to search for a named library, if it isn't part of
the standard C library. For math, you have to supply <code>-lm</code> at the end of the
flags. This is because it is a <strong>linker flag</strong> (i.e. <code>LDFLAGS</code>), which must be
put at the end of the command.</p>
<ul>
<li><code>M_E</code>: $e$.</li>
<li><code>M_PI</code>: $\pi$.</li>
<li><code>M_SQRT2</code>: $\sqrt{2}$.</li>
<li><code>sin(x)</code>: Sine in radians.</li>
<li><code>cos(x)</code>: Cosine in radians.</li>
<li><code>tan(x)</code>: Tangent in radians.</li>
<li><code>asin(x)</code>: Arcsine in radians.</li>
<li><code>acos(x)</code>: Arc-cosine in radians.</li>
<li><code>atan(x)</code>: Arctangent in radians.</li>
<li><code>atan2(y, x)</code>: Find angle $\theta$ that points from $(0, 0)$ to $(x, y)$.</li>
<li><code>exp(x)</code>: $e^x$.</li>
<li><code>exp2(x)</code>: $2^x$.</li>
<li><code>exp10(x)</code>: $10^x$.</li>
<li><code>log(x)</code>: $ln(x)$.</li>
<li><code>log2(x)</code>: $log_2(x)$.</li>
<li><code>log10(x)</code>: $log_{10}(x)$.</li>
<li><code>pow(x, y)</code>: $x^y$.</li>
<li><code>sqrt(x)</code>: $\sqrt{x}$.</li>
<li><code>round(x)</code>: Nearest integer as double.</li>
<li><code>fabs(x)</code>: Absolute value.</li>
<li><code>floor(x)</code>: Floor.</li>
<li><code>ceil(x)</code>: Ceiling.</li>
<li><code>fmod(x, y)</code>: Floating point modulus.</li>
</ul>
<h1 id="memory-segmentation">Memory Segmentation</h1>
<p>Memory in C is segmented into the machine code, statically-allocated data, the
heap, and the stack:</p>
<dl>
<dt>Memory Segmentation in C</dt>
<dd><img src="memory_segmentation.png" alt="Memory Segmentation in C"></dd>
</dl>
<p>An important note is that scope isn't the same as storage class. Storage class
is an implementation/memory concept, while lifetime is a compiler/coding
concept. So, for example, you can create <code>static</code> local variables. This isn't
recommended though because it is confusing.</p>
<h2 id="machine-code">Machine Code</h2>
<p>The actual compiled procedures and statements that run your code.</p>
<h2 id="staticglobal-variables">Static/Global Variables</h2>
<p>Variables with static storage are initialized at start up (really at
compile-time). If you don't initialize them, they have a zero value. If you do,
they must be initialized to a constant expression.</p>
<p>Note: C isn't very smart with constant expressions. If a global variable A is
set to a constant expression and global variable B is set to A. A is considered
constant and B is not:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">char</span> globalC <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">a</span><span style="color:#f1fa8c">&#39;</span>; <span style="color:#6272a4">// Yes
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> globalI <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">15</span> <span style="color:#ff79c6">+</span> (<span style="color:#bd93f9">39</span> <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">3</span>); <span style="color:#6272a4">// Yes
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> globalJ <span style="color:#ff79c6">=</span> globalI <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">// No
</span></code></pre></div><h2 id="heap">Heap</h2>
<p>Data from the heap is explicitly requested and is explicitly released.</p>
<h2 id="stack">Stack</h2>
<p>All local variables are initialized on the stack by default. Variables
initialized on the stack must have a size known at compile-time. Otherwise, you
must allocate it dynamically on the heap and store a reference/pointer to it.</p>
<h1 id="pointers">Pointers</h1>
<p>In C, <strong>everything</strong> is passed by value. To get around always copying the data
we care about, we use pointers and dereferencing. <em><strong>Creating diagrams where
variable are nodes are your friend!</strong></em></p>
<p>Pointers are simply memory addresses with a method of getting the value at that
memory address. Really, pointers are to the start of a memory block and the
type of the pointer determines the size of the block.</p>
<p>When declaring a pointer, the number of asterisks (<code>*</code>) describes how deep you
have to go before you reach the given type. I personally think this is easiest
to understand by postfixing the type with <code>*</code>, since it is distinct from
dereferencing, but that isn't always standard.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> a; <span style="color:#6272a4">// just a int
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>b; <span style="color:#6272a4">// pointer to a char
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">float</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">*</span>c; <span style="color:#6272a4">// pointer to a pointer to a float
</span></code></pre></div><p>When using a declared pointer, you can use the <strong>dereference operator</strong> by
prefixing the name by <code>*</code>. This says to follow the pointer to get the value of
that memory address. (You technically could do this for any <code>size_t</code>, but
that's unsafe and error-prone so C stops you.) This can be applied $n$ times
where $n$ is the number of asterisks you used when declaring the pointer (i.e.
how deep the pointer is).</p>
<p>When using any variable, you can use the <strong>address of</strong> operator by prefixing
the name by <code>&amp;</code>. This gets the address of the variable in memory. (You can't
apply this multiple times because C doesn't implicitly declare a variable when
using <code>&amp;</code>, so there is no memory address to get for <code>&amp;&amp;</code>.)</p>
<p>Putting it all together.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> a <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>; <span style="color:#6272a4">// int &#39;a&#39; with value 5.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>pa; <span style="color:#6272a4">// int pointer &#39;pa&#39;.
</span><span style="color:#6272a4"></span>pa <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>a; <span style="color:#6272a4">// make pa point to a.
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// Do the same but briefer
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>pa <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>a;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> a <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>; <span style="color:#6272a4">// int
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>pa <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>a; <span style="color:#6272a4">// int pointer
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">*</span>ppa <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>pa; <span style="color:#6272a4">// int double pointer
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">*</span>pa <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span><span style="color:#ff79c6">*</span>ppa <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">// a = 6, *pa = 6, **ppa = 6
</span></code></pre></div><p>There also exists a special macro constant called <code>NULL</code>. This is just <code>*0</code>.
This just means a pointer to memory address 0, which is either an invalid or
protected segment of memory.</p>
<p>Wait a minute! You just said we can have pointers to invalid/protected segments
of memory. We can also do pointer arithmetic to directly muck with pointers.
Isn't this unsafe?</p>
<p><strong>Yes!</strong> Trying to access an invalid segment of memory causes your OS to
immediately terminate your program with a &ldquo;segmentation fault&rdquo;. This is like
the <code>NullPointerException</code> from Java except unrecoverable.</p>
<p><strong>Note:</strong> Pointers in C do not follow type promotion semantics because they use
type to determine how much memory they look at. For example, if you wanted to
make a <code>int*</code> point to a <code>char</code>, the pointer would look for 4 bytes while the
<code>char</code> only is 1 byte. (You can silence these with casting, but why would you
want to?)</p>
<h2 id="some-odd-syntax">Some Odd Syntax</h2>
<p>It is important to realize that <code>[]</code> (arrays) have higher precedence than <code>*</code>
when declaring. This means</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// I am an array of 10 int pointers
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>ap[ <span style="color:#bd93f9">10</span> ];
<span style="color:#6272a4">// I think this is clearer here
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">*</span> ap[<span style="color:#bd93f9">10</span>];
</code></pre></div><p><code>const</code> is another type operator (like <code>[]</code> or <code>*</code>). This just says, don't let
me change this value during it's lifetime. This has some non-obvious
interactions with pointers. Most of the time, you'll just use <code>const</code> pointers
to declare to users that you won't change the value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span> x <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>a; <span style="color:#6272a4">// pointer to a const int
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">const</span> y <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>b; <span style="color:#6272a4">// const pointer to a int
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">const</span> z <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>c; <span style="color:#6272a4">// const pointer to a const int
</span></code></pre></div><h2 id="pointer-arithmetic">Pointer Arithmetic</h2>
<p>You can do integer arithmetic directly on pointers. When you add a number <code>n</code>
to a pointer <code>p</code>, you're actually shifting the pointer over by <code>n</code> times the
<code>sizeof(*p)</code>. For example</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// These are all play examples
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">short</span> <span style="color:#ff79c6">*</span>a <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
a <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">// shifts a over 2 bytes
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>b <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
b <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>; <span style="color:#6272a4">// shifts b over 4 bytes
</span></code></pre></div><p>Using this, you can really easily see that array notation is really syntactic
sugar for pointer arithmetic, which means you can use array notation for any
pointer! So,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> i;
<span style="color:#8be9fd">int</span> a[<span style="color:#bd93f9">10</span>];
a[i] <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(a <span style="color:#ff79c6">+</span> i);
</code></pre></div><p>Weirdly, this means you can also swap the array and the index because addition
is commutative.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> i;
<span style="color:#8be9fd">int</span> a[<span style="color:#bd93f9">10</span>];
a[i] <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(a <span style="color:#ff79c6">+</span> i);
</code></pre></div><p><em>Why do we use arrays at all then?</em> Well, static arrays have stronger type
checking (can't change their length) and <code>sizeof</code> returns the number of bytes
in the static array, rather than the number of bytes in the pointer.</p>
<h2 id="pointer-iteration">Pointer Iteration</h2>
<p>You can use pointers to iterate over collections. This is generally more
performant as you don't have to do integer arithmetic and incrementation every
loop. Just incrementation.</p>
<p>However, this is generally pretty overkill because integer arithmetic is very
cheap, and the compiler is very good. It also is a little harder to think
about, so it's not recommended unless you have a <strong>good</strong> reason to do so.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> a[] <span style="color:#ff79c6">=</span> { <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">9</span>, <span style="color:#bd93f9">16</span>, <span style="color:#bd93f9">25</span> };
<span style="color:#8be9fd">int</span> len <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">sizeof</span>( a ) <span style="color:#ff79c6">/</span> <span style="color:#ff79c6">sizeof</span>( a[ <span style="color:#bd93f9">0</span> ] );
<span style="color:#6272a4">// This points right after the array. This is okay as long as we don&#39;t dereference it
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>end <span style="color:#ff79c6">=</span> a <span style="color:#ff79c6">+</span> len;
<span style="color:#8be9fd">int</span> sum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
<span style="color:#ff79c6">for</span> ( <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>p <span style="color:#ff79c6">=</span> a; p <span style="color:#ff79c6">&lt;</span> end; p<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span> ) {
  sum <span style="color:#ff79c6">+</span><span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>p;
}
<span style="color:#ff79c6">return</span> sum;
</code></pre></div><h2 id="void-pointers">Void Pointers</h2>
<p>Sometimes, you're lazy or can't know about what your pointer points to. To
handle this, we use void pointers, which are just memory addresses that can
point to anything. We receive void pointers from <code>malloc</code>, which we'll get
later.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>ptr; <span style="color:#6272a4">// We now have a void pointer
</span></code></pre></div><h1 id="dynamic-allocation">Dynamic Allocation</h1>
<p>For the stack, you must know how much memory you want to allocate at compile
time so that the compiler will know where to put things without overwriting
them. The stack also has limited size. As you can see, <em>the stack is limited</em>.</p>
<p>If you want more memory or to dynamically allocate your memory. You need to use
the heap. However, you have to (mostly) manually manage this memory using
<code>malloc</code> (memory allocate) and <code>free</code> (release allocated memory back to OS).</p>
<p>When you use <code>malloc</code>, you as for a certain number of bytes of memory and you
will receive a pointer to the first address. If there is no memory, it returns
<code>NULL</code>. When you use <code>free</code>, you simply provide the address to the <strong>first
address</strong> you received from <code>malloc</code>. <code>free</code> knows how much memory to release
because <code>malloc</code> and <code>free</code> track the memory used.</p>
<p><code>malloc</code> and <code>free</code> are declared in <code>stdlib.h</code> with the following signature:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// stdlib.h
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span><span style="color:#50fa7b">malloc</span>(size_t size); <span style="color:#6272a4">// returns memory address
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">free</span>(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>memoryAddress);
</code></pre></div><p>A common usage of dynamic allocation is for large or variable length arrays.
This is useful when you don't have enough space, can't know at compile time, or
can't be bothered to make it known at compile time. For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&lt;stdlib.h&gt;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#6272a4">// Allocate a dynamic array for 1000 integers
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>list <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>) malloc(<span style="color:#bd93f9">1000</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#8be9fd">int</span>)); <span style="color:#6272a4">// how they like to do it
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>list <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">1000</span> <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">sizeof</span> <span style="color:#ff79c6">*</span>list); <span style="color:#6272a4">// the zen way
</span></code></pre></div><h2 id="dynamic-allocation-hazards">Dynamic Allocation Hazards</h2>
<p>Dynamic allocation has a lot of issues. Taken together, we call these issues
memory safety issues.</p>
<ul>
<li>Segmentation Faults: We forget to check that <code>malloc</code> returns null. Your
program will just crash.</li>
<li>Buffer Overflow: We try to write outside of our memory bounds. This may cause
invalidation of important memory or cause you to read invalid memory.</li>
<li>Memory Leak: We forget to use <code>free</code> in certain cases. This causes your
program to keep using more and more memory until you crash. You also get
performance issues.</li>
<li>Mistaken <code>free</code>s: You free memory you didn't <code>malloc</code>.</li>
<li>Multiple <code>free</code>s: You free memory multiple times. You might invalidate memory
management data structures. May allow that memory to be <code>malloc</code>'d twice.</li>
<li>Dangling Pointer / Use After <code>free</code>: You try to access memory after you
<code>free</code> it. You'll either get garbage, old invalid data, or malicious code.
<em>Really hard to debug</em>.
<ul>
<li>Set the given pointer to <code>NULL</code> to avoid! Then you just crash.</li>
</ul>
</li>
</ul>
<h2 id="dynamic-allocation-benefits">Dynamic Allocation Benefits</h2>
<p>Yes, dynamic allocation is more expensive, since you must call the OS. It's
also hard to work with.</p>
<p>However, it does have benefits. You can store pointers to valid memory across
multiple procedure calls. You can allocate larger things. You can allocate
things not known at compile time.</p>
<p>A great usage of this is <strong>resizing arrays</strong>. This is basically the same as
Java. You create some initial array. Then you can add, remove, and access
things in it. When you run out of space, you create a new array that's larger,
you copy everything from your old array into it, you update your pointer to
point into the new memory, and then you free the old memory. It's a good idea
to <strong>double the length of the array</strong> each time, because this gives us an
amortized cost of $O(1)$, since <code>malloc</code> is slow.</p>
<h2 id="move-and-copy">Move and Copy</h2>
<p>C has some convenience methods that allow you to more easily copy arbitrary
memory:</p>
<ul>
<li><code>void *memcpy(void *dest, void const *src, size_t n)</code>: Copy <code>n</code> bytes from
<code>src</code> to <code>dest</code>, keeping them both.</li>
<li><code>void *memmove(void *dest, void const *src, size_t n)</code>: Copy <code>n</code> bytes from
<code>src</code> to <code>dest</code>, <code>free</code>ing <code>src</code>.
<ul>
<li>A little more expensive than <code>memcpy</code>.</li>
</ul>
</li>
<li><code>void *realloc(void *ptr, size_t size)</code>: Changes the size of the allocated
memory address to the given size. It returns the address of the reallocated
block.
<ul>
<li>When growing the array, it increases the size in place, if possible. If it
can't, it finds where the memory can be allocated and then copies and moves
everything over.</li>
<li>When shrinking the array, it decreases the size in place, discarding the
data that doesn't fit.</li>
<li><strong>You should always use the value it returns. Don't assume it will be the
same.</strong></li>
</ul>
</li>
</ul>
<h1 id="managing-larger-projects">Managing Larger Projects</h1>
<p>In C, to use variables and functions from other files, you must declare the
variable and function prototype for the compiler to allow you to use the
values. The linker will link the declarations in the object (<code>*.o</code>) files into
a single executable.</p>
<p>To declare a variable without allocating it, you must use <code>extern</code> when
declaring the variable.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// There exists some global named x. I don&#39;t know where, but it&#39;s there and I
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// want it.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">extern</span> <span style="color:#8be9fd">int</span> x;
</code></pre></div><p>To declare a function, you just declare the function prototype.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// There exists some global procedure named f. I don&#39;t know where, but it&#39;s
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// there and I want it.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">f</span>( x );
</code></pre></div><p>However, every file that uses these globals and functions declared in some file
(say <code>stuff.c</code>) must have these exact same declarations to access parts of
<code>stuff.c</code>. Manually declaring these dependencies is brittle and annoying. This
lead us to header files and the <code>#include</code> preprocessor directive.</p>
<h2 id="header-files">Header Files</h2>
<p>Header files are C files that contain only declarations of procedures and
globals. Each source file (<code>*.c</code>) that exports some procedures or globals
declares them in its corresponding header file (<code>*.h</code>). Users then <code>#include</code>
the header files from the libraries they want to use.</p>
<p>How do these work? Well, <code>#include</code> just pastes the contents of the included
file. This gives you the declarations of the header file, allowing you to use
the declared items. When you compile the source file (<code>*.c</code>) into an object
file (<code>*.o</code>), you have these external declarations that must (or at least
should) be defined. Then, when you go to produce the executable, the linker
takes your object file along with the object file (<code>*.o</code>) for your library,
links the declarations in your object file to the definition/implementations in
the library. It then produces an executable.</p>
<p><strong>Note:</strong> It is a good practice for a source file to include its own header
file. This detects disagreements with declaration and implementation and won't
compile if there is one.</p>
<p>The linker then takes the object</p>
<p>If you put <code>static</code> in front of a global variable or procedure definition, you
get internal linkage, meaning others can't use it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#6272a4"># Compile main.c into main.o but don&#39;t link it.</span>
$ gcc -c main.c
</code></pre></div><h1 id="goto">Goto</h1>
<p>Goto is now considered bad, unsafe, and abstract-breaking. However, this is
how machine code does branching, so we'll cover how C does it.</p>
<p>Any statement in C can be labeled with a label on its own line like so</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd;font-style:italic">label_name</span>:
printf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%s</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">bro</span><span style="color:#f1fa8c">&#34;</span>);

<span style="color:#6272a4">// more code...
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">goto</span> label_name;
</code></pre></div><p>However, C does have a slightly muzzled goto. You can't goto another label in
another procedure/function. You can, however, go to inner and outer code
blocks.</p>
<h1 id="side-effects">Side Effects</h1>
<p>Side effects are just when some procedure modifies or manipulates a piece of
data directly. This affects the caller sometimes in unexpected ways.</p>
<p>This a common source of bugs and is very difficult to fix efficiently in C.
Commonly, the solution is just RTFM, which isn't great.</p>
<p>Side effects are hard to reason about because they are hard to notice and are
strongly affected by performance and sequence points. Sequence points are
essentially just where C finishes a statement. These are the following: <code>;</code>,
<code>,</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>?</code>.</p>
<h1 id="procedure-evaluation">Procedure Evaluation</h1>
<p>The C compiler matches the called procedure's name and its actual parameters
with the formal parameters of the procedure.</p>
<ul>
<li>
<p>Actual Parameters: Types of arguments passed in before types are promoted.</p>
</li>
<li>
<p>Formal Parameters: Types of parameters the procedure expects.</p>
</li>
</ul>
<p>Procedures in C can only return one value, like Java. This is sad, but we get
around it by taking in pointers which we fill with values normally.</p>
<h2 id="procedure-declaration">Procedure Declaration</h2>
<p>We can declare functions, which helps the C compiler be aware of what
procedures we have. This is a core part of a header file! (which we haven't
gotten to yet). Function declarations look like the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Declaration. Variable names are optional, but sometimes good for
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// documentation.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">expunge</span>( <span style="color:#8be9fd">float</span> x, <span style="color:#8be9fd">long</span> y );

<span style="color:#6272a4">// Definition.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">expunge</span>( <span style="color:#8be9fd">float</span> x, <span style="color:#8be9fd">long</span> y )
{
  <span style="color:#6272a4">// do things
</span><span style="color:#6272a4"></span>}
</code></pre></div><h2 id="variadic-procedure">Variadic Procedure</h2>
<p>You can also have variadic arguments via a few special procedures. A variadic
function looks something like the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">printFloats</span>( <span style="color:#8be9fd">int</span> n, ... );
</code></pre></div><p>We'll get more into this later.</p>
<h2 id="performance-considerations">Performance Considerations</h2>
<p>It is (somewhat) important to note that procedure calls aren't free (duh!). We
have to transfer control to another procedure, by saving the parameters,
allocating variables on the stack for the procedure, save the return address,
jump to the procedure's address, do the things, clear the stack, and jump back
to the caller.</p>
<p>In Java, we have procedures (there, methods) check for the validity of their
arguments and complain when they are invalid. This is normally a <strong>fantastic
idea</strong>; however, this does add additional overhead on calling procedures. If we
want a performance boost, when can declare that the procedure shall have
undefined behavior for invalid values and thus place the onus of validation on
the caller. This is <strong>normally</strong> a <strong>bad idea</strong>, since they aren't that
expensive and can remove a whole class of errors.</p>
<h1 id="arrays">Arrays</h1>
<p>C arrays are syntactically similar to Java.</p>
<h2 id="allocation">Allocation</h2>
<p>However, in C arrays are either allocated statically or dynamically. Statically
allocated arrays must have a constant expression for their length (known at
compile time) and because they are allocated on the stack. Dynamically
allocated arrays can have a length only known at runtime, but must be allocated
on the heap. (We store a pointer to the first element in the array.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Declare and allocate an array of length 10
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> a[<span style="color:#bd93f9">10</span>];
<span style="color:#6272a4">// Declare and allocate an array of length 10. Initialize array to zero.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> a[<span style="color:#bd93f9">10</span>] <span style="color:#ff79c6">=</span> {};
<span style="color:#6272a4">// Declare and allocate array and partially initialize it.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> a[<span style="color:#bd93f9">10</span>] <span style="color:#ff79c6">=</span> {<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>};
<span style="color:#6272a4">// Declare and allocate an array large enough to fit the given data.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> a[] <span style="color:#ff79c6">=</span> {<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>};
<span style="color:#6272a4">// Declare and allocate an array large enough to fit the given data. Giving
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// indexes. Elements unspecified are zeroed.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> a[] <span style="color:#ff79c6">=</span> {[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, [<span style="color:#bd93f9">6</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>};
<span style="color:#6272a4">// {0, 0, 0, 1, 2, 0, 3}
</span></code></pre></div><p>In Java, all arrays are dynamically allocated on the heap, but Java manages it
behind the scenes.</p>
<h2 id="multi-dimensional-arrays">Multi-Dimensional Arrays</h2>
<p>For multi-dimensional arrays, C uses the same syntax as Java.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Declare and allocate 2D array with 3 rows and 4 columns.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> table[<span style="color:#bd93f9">3</span>][<span style="color:#bd93f9">4</span>];
<span style="color:#6272a4">// Declare and allocate 2D array with 3 rows and 4 columns. Initialize to zero.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> table[<span style="color:#bd93f9">3</span>][<span style="color:#bd93f9">4</span>] <span style="color:#ff79c6">=</span> {};
<span style="color:#6272a4">// Declare and allocate 2D array with 3 rows and 4 columns. Initialize values.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> table[<span style="color:#bd93f9">3</span>][<span style="color:#bd93f9">4</span>] <span style="color:#ff79c6">=</span> {
  {<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">9</span>},
  {<span style="color:#bd93f9">16</span>, <span style="color:#bd93f9">25</span>, <span style="color:#bd93f9">36</span>, <span style="color:#bd93f9">49</span>},
  {<span style="color:#bd93f9">64</span>, <span style="color:#bd93f9">81</span>, <span style="color:#bd93f9">100</span>, <span style="color:#bd93f9">121</span> }
};
<span style="color:#6272a4">// Declare and allocate 2D array with 3 rows and 4 columns. Partially
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// initialize values. All other values initialized to zero.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> table[<span style="color:#bd93f9">3</span>][<span style="color:#bd93f9">4</span>] <span style="color:#ff79c6">=</span> {
  {<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>},
  {<span style="color:#bd93f9">16</span>, <span style="color:#bd93f9">25</span>, <span style="color:#bd93f9">36</span>, <span style="color:#bd93f9">49</span>},
  {<span style="color:#bd93f9">64</span>}
};
<span style="color:#6272a4">// We also have the special indexing initialization.
</span></code></pre></div><p>C can only infer the size of the outermost array. It cannot for any inner
array. It does this because then you would have arrays to pointers, which we'd
then have to individually initialize. This syntax is supposed to create a local
block of memory. Having an array of pointers to another arrays would not be
local. This isn't what what we'd expect, so we don't do it.</p>
<p>For some reason, C can only infer the size of the outer array. I haven't quite
figured out why it doesn't take the max of the inferred size of the inner
arrays. Maybe it's error prone?</p>
<p>C arranges multi-dimensional arrays in <strong>row-major order</strong>. Essentially, it
arranges everything as a string, where the outer dimension is more significant
than the inner. (This is only for <strong>statically allocated</strong> arrays!)</p>
<p>This method of memory allocation makes indexing faster. In Java, we have an
array on the heap of pointers to other arrays on the heap.</p>
<h3 id="unspecified-lengths">Unspecified Lengths</h3>
<p>In C, you can have unspecified lengths for outer arrays, but you <strong>must</strong> have
the length for the inner array, if you're initializing this. We'll get into this more in [Arrays are Just Pointers]. However, suffice it to say</p>
<h3 id="limitations">Limitations</h3>
<p>Since the stack is only so, we can't create HUGE arrays on the stack (e.g.
<code>int[1000000]</code>). To normal workaround is to either use the heap or to use a
<code>static</code> lifetime array, so the compiler properly plans ahead.</p>
<h2 id="variable-length-arrays">Variable Length Arrays</h2>
<p>C99 began to allow for variable length arrays on the stack.</p>
<p><strong>TODO: Write more</strong>.</p>
<h2 id="arrays-are-just-pointers">Arrays are Just Pointers</h2>
<p>In C, arrays are just pointers with nice syntax for creating and pointer
arithmetic. This is easiest to see with procedure parameters (e.g. <code>int test[]</code>). We don't know the size of the array because it's just a pointer!</p>
<p>Since we don't know the size of the array, we can't safely iterate over it. To
account for this, we normally take length as a parameter.</p>
<p><strong>Note:</strong> This requires us to trust the caller. This is another security issue.</p>
<h3 id="inner-dimensions">Inner Dimensions</h3>
<p>You may be confused why we declare the inner dimension of an array in
procedures. We don't strictly need to (Java doesn't), but this allows us to
have faster, smaller, more local memory. The reason it allows this is because
it means C doesn't make your array an array of pointers to arrays, but instead
an array of statically allocated arrays.</p>
<p>This may be initially confusing, but realize that array syntax is just
syntactic sugar for pointer syntax.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// array syntax
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">foo</span>(<span style="color:#8be9fd">int</span> array[][<span style="color:#bd93f9">3</span>]);
<span style="color:#6272a4">// pointer syntax, equivalent
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">foo</span>(<span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>array)[<span style="color:#bd93f9">3</span>]);
</code></pre></div><p>Now you should be able to more easily see that we need to know what our pointer
points to. If we had <code>int array[][]</code>, we'd really just have a double pointer
(e.g. <code>int **array</code>). That is, we'd have an array that pointed to other arrays.</p>
<p>Sometimes this is what you want, sometimes not.</p>
<h2 id="bounds-checking">Bounds Checking</h2>
<p>Unlike almost every other language, C has no bounds checks for array access.</p>
<p>This basically means you can write or read memory on accident. This is called
<strong>buffer overflows</strong>.</p>
<p>Sadly, bugs like this normally fail at some future point and cause <em>security</em>
issues. Exploits using array bound checking issues are called <strong>stack
smashing</strong> exploits. There are several static analysis tools (clang, fortify,
etc.)</p>
<p>Worst case, these bugs arise as segmentation faults (trying to access memory
forbidden by OS). Sometimes you also get a bus error.</p>
<h1 id="function-pointers">Function Pointers</h1>
<p>Realize that procedures/functions are really just the address of the first
instruction in the procedure. This means we can pass them around and call them!
We just need some (type) semantics to make sure the compiler know what to do
with args and to be (somewhat) safe.</p>
<p>Procedures/functions have a type based off of their parameters and their return
value.</p>
<h2 id="syntax">Syntax</h2>
<p>C has some pretty garbage syntax for function pointers IMO. This comes from it
not having a function keyword.</p>
<p>Here's a quick breakdown of the syntax.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Declare a variable called foo which is a pointer to a function that takes in
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// a pointer to a character and returns an integer.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>foo)(<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span>);

<span style="color:#6272a4">// Declare a function that takes in a function which takes a character and
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// returns an integer.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">someFunc</span>(<span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>)(<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span>));

<span style="color:#6272a4">// Declare an array of function pointers. Call this array testList
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">bool</span> (<span style="color:#ff79c6">*</span>testList[<span style="color:#bd93f9">10</span>]) (<span style="color:#8be9fd">int</span>);
</code></pre></div><p>When we assign function pointers, we're technically supposed to use the <code>&amp;</code>
address of operator. And then, when we apply them, we should dereference them
(<code>*</code>). For example,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>funcPtr)() <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>func;
<span style="color:#6272a4">// Apply it
</span><span style="color:#6272a4"></span>(<span style="color:#ff79c6">*</span>funcPtr)();
</code></pre></div><p>However, this is pretty garbage syntax for something that is unambiguous, since
we can't do arithmetic on function pointers. Therefore, C allows us to not use
those operators and instead do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">int</span> (<span style="color:#ff79c6">*</span>funcPtr)() <span style="color:#ff79c6">=</span> func;
<span style="color:#6272a4">// Apply it
</span><span style="color:#6272a4"></span>funcPtr();
</code></pre></div><h2 id="why">Why?</h2>
<p>Well, first off, it allows for basic, low level first class functions, which is
rad. More practically, it allows for the strategy pattern, the chain of
command pattern, and callbacks.</p>
<p>The strategy pattern is where we have a common function that takes a specific
function that changes its behavior. Imagine we have a function that plays a
game and takes in a strategy, which is itself a function. This allows for
easier modification and more code reuse.</p>
<p>The chain of command pattern is where we apply a series of functions, taking
the first successful output.</p>
<h1 id="struct">Struct</h1>
<p>Structs are what has made C last so long.</p>
<p>A struct is just a collection of heterogeneously typed, named fields stored
contiguously. We access the field of a struct <code>a</code> using <code>a.fieldName</code> struct.
We access the field of a struct pointer <code>aPtr</code> using <code>aPtr-&gt;fieldName</code>.</p>
<p>Structs have unspecified order within the struct. This is so that we can make
platform-specific optimizations. For example, most architectures have some sort
of &ldquo;alignment&rdquo; for their data (e.g. 2-byte alignment, 4-byte alignment). Data
that is aligned is faster to access. Data that is not aligned is slower to
access.</p>
<dl>
<dt>Poorly Aligned Struct, using given order</dt>
<dd><img src="misaligned_struct.png" alt="Poorly Aligned Struct, using given order"></dd>
<dt>Well Aligned Struct, overriding given order</dt>
<dd><img src="aligned_struct.png" alt="Well Aligned Struct, overriding given order"></dd>
</dl>
<h2 id="semantics">Semantics</h2>
<p>Like everything in C, <code>struct</code>s are passed by value and allocated on the stack.
However, you can have enormous structs. Therefore, we normally work with
pointers to <code>struct</code>s!</p>
<p>When working with <code>struct *</code>s you have the choice of using <code>*</code> with <code>.</code> to
deference and get fields, or the nicer <code>-&gt;</code> syntax (see [Pointers to Structs]).</p>
<p>When returning <code>struct</code>s within procedures, you must be careful. If you return
it by value, that might be slow but you'll be safe. If you return a pointer,
make sure you won't get a dangling pointer (i.e. make sure that you <code>malloc</code>
the <code>struct</code> and later free it in the caller).</p>
<h2 id="syntax-1">Syntax</h2>
<h3 id="named-structs">Named Structs</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Declare a struct
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> StructName {
  type name;
  ...
};

<span style="color:#6272a4">// Declare example struct
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Person {
  <span style="color:#8be9fd">char</span> name[ <span style="color:#bd93f9">12</span> ];
  <span style="color:#8be9fd">double</span> height;
  <span style="color:#8be9fd">int</span> age;
};


<span style="color:#6272a4">// Declare an uninitialized person struct
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Person p1;
<span style="color:#6272a4">// Initialize the struct
</span><span style="color:#6272a4"></span>p1.height <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.75</span>;
p1.age <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">24</span>;
<span style="color:#6272a4">// Note that we can&#39;t do p1.name = &#34;William&#34; because we used array syntax when declaring
</span><span style="color:#6272a4"></span>strcpy(p1.name, <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">William</span><span style="color:#f1fa8c">&#34;</span>);

<span style="color:#6272a4">// Declare and initialize a struct
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Person p2 <span style="color:#ff79c6">=</span> { <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">William</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#bd93f9">1.85</span>, <span style="color:#bd93f9">27</span> };

<span style="color:#6272a4">// More explicit initialization syntax
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Person p3 <span style="color:#ff79c6">=</span> {
  .age <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">33</span>,
  .name <span style="color:#ff79c6">=</span> “Agatha”,
  .height <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.7</span>
};
</code></pre></div><h3 id="anonymous-structs">Anonymous Structs</h3>
<p>We can declare anonymous <code>struct</code>s by just not giving them a name. These are
useful for global <code>struct</code>s (like singletons) or one-time use <code>struct</code>s. No
other <code>struct</code> has the same type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Declare anonymous struct with an instance named varName
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  type name;
  ...
} varName;

<span style="color:#6272a4">// Typedef a struct. Basically assign the anonymous struct type to the given.
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// This is hotly debated. I generally don&#39;t like for non-opaque types.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  <span style="color:#8be9fd">int</span> foo;
  <span style="color:#8be9fd">char</span> bar;
} Example;
</code></pre></div><h3 id="pointers-to-structs">Pointers to Structs</h3>
<p>Since <code>struct</code>s are passed by value, like everything in C, and <code>struct</code>s can
get large, we like to deal with <code>struct *</code>s. This means, to get a field on the
<code>struct *</code>, we must first dereference it (duh). This looks like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// readStruct returns a pointer to an malloc&#39;d struct. We won&#39;t free that here.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Person <span style="color:#ff79c6">*</span>p1 <span style="color:#ff79c6">=</span> readStruct();
printf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%s</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, (<span style="color:#ff79c6">*</span>p1).name);
</code></pre></div><p>However, this gets really ugly with nested pointers, nested structs, and even
basic things like this. Therefore, we invented <code>-&gt;</code> syntax, which is just <code>*</code>
and <code>.</code> combined. The above would like like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// readStruct returns a pointer to an malloc&#39;d struct. We won&#39;t free that here.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Person <span style="color:#ff79c6">*</span>p1 <span style="color:#ff79c6">=</span> readStruct();
printf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%s</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, p1<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>name);
</code></pre></div><h1 id="typedef">Typedef</h1>
<p>Typedef is used by the compiler to create aliases for types (not actually
defining new types!).</p>
<p>When to use typedef is debated. Generally, you should only do it when you have
a <strong>good reason</strong> to. Otherwise, it can add more cognitive load to people
keeping track of what your types are.</p>
<p><strong>Note:</strong> A typedef only applies after the line on which the typedef occurred,
for some reason.</p>
<h2 id="syntax-2">Syntax</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// General Syntax. For types such as arrays, the name must be mixed with the
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// type because C has annoying syntax.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> TYPE IDENTIFIER;

<span style="color:#6272a4">// &#34;Complex&#34; basic type. Generally not recommended.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#8be9fd">char</span> Table[NUM_ROWS][NUM_COLS];

<span style="color:#6272a4">// Pointer type. Strongly advised against.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>str;

<span style="color:#6272a4">// Anonymous enum. Generally not recommended.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">enum</span> { NAME1, NAME2 } ExampleEnum;

<span style="color:#6272a4">// Anonymous struct. Generally not recommended.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  <span style="color:#8be9fd">int</span> field1,
  <span style="color:#8be9fd">char</span> field2,
} ExampleStruct;
</code></pre></div><h2 id="recommendations">Recommendations</h2>
<p>First off, you should generally not use typedef a bunch. It is very weak in C
because you can use the original type and the aliases type interchangeably, so
it doesn't add much type safety. It also doesn't allow for any behaviors (like
associated methods in Go). Additionally, people don't expect to see several
typedefs in C code.</p>
<p>You should <strong>never</strong> typedef a pointer type. This adds an incredibly amount of
cognitive load, since whether or not a value is a pointer changes both the
semantics and the syntax of the type. For example, people could pass their type
to a procedure and expect it to be passed by value (because it says it is), but
then the procedure mutates their variable.</p>
<p>There are two strong cases for using typedef. When you have compiler flags
which you want to change the types (using <code>#ifdef</code>) and when you have a
complex, completely opaque type to the consumer (opaque means the user does not
interact with it directly).</p>
<p>Using specific types is normally not necessary unless you have had issues with
a specific architecture (don't do premature optimization!). If you do a
typedef, then you only have one <code>#ifdef</code>, like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">#</span><span style="color:#ff79c6">ifdef SOME_PREPROCESSOR</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">typedef</span> Something uint16_t
<span style="color:#ff79c6">#</span><span style="color:#ff79c6">else</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">typedef</span> Something uint32_t
<span style="color:#ff79c6">#</span><span style="color:#ff79c6">endif</span><span style="color:#ff79c6">
</span></code></pre></div><p>An example of a completely opaque type is <code>FILE</code>, where you only interact with
it through accessor/mutator procedures. This simplifies the client code and
allows you more flexibility with modifying the type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// We declare the following anonymous struct to have the name OpaqueStruct
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// This means you can use the type as OpaqueStruct instead of struct OpaqueStruct.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  <span style="color:#8be9fd">int</span> field1,
  <span style="color:#8be9fd">char</span> field2,
} OpaqueStruct;
</code></pre></div><h1 id="data-structures">Data Structures</h1>
<p>There are two main ways to keep data organized. You can either keep it all in
one place (i.e. arrays and structs), or you can use links/pointers (i.e. linked
data structures).</p>
<dl>
<dt>Linked List</dt>
<dd><img src="linked_list.png" alt="Linked List"></dd>
</dl>
<p>Here's a quick comparison of the benefits two</p>
<ul>
<li>Contiguous Memory:
<ul>
<li>Can use (pointer) arithmetic to quickly and randomly access any data.</li>
<li>Very simple for fixed-size data.</li>
</ul>
</li>
<li>Linked Memory:
<ul>
<li>Easier to grow and add stuff to.</li>
<li>Doesn't require large, contiguous section of memory.</li>
<li>Are more intuitive for certain data structures (e.g. graphs)</li>
</ul>
</li>
</ul>
<h2 id="linked-list-example">Linked List Example</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Create a struct with a useful short name and long name
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> NodeStruct {
  <span style="color:#8be9fd">int</span> value;
  <span style="color:#6272a4">// We must use struct NodeStruct, because the typedef only applies after the
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// typedef in the file
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> NodeStruct <span style="color:#ff79c6">*</span>next;
} Node;

Node <span style="color:#ff79c6">*</span>head <span style="color:#ff79c6">=</span> malloc(<span style="color:#ff79c6">sizeof</span>(Node));
<span style="color:#ff79c6">*</span>head <span style="color:#ff79c6">=</span> (Node) {
  .value <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
  .next <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
}

<span style="color:#6272a4">// Simple traversal, relying on next being NULL at the end of the list and NULL
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// being falsey
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">for</span> ( Node <span style="color:#ff79c6">*</span>n <span style="color:#ff79c6">=</span> head; n; n <span style="color:#ff79c6">=</span> n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next ) {
  printf( <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">%d </span><span style="color:#f1fa8c">&#34;</span>, n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>value );
}
printf( <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span> );
</code></pre></div><h2 id="simple-object-orientation">Simple Object Orientation</h2>
<p>In C, object orientation is achieved by having procedures that take the first
parameter as a pointer to your type. Then, the procedure mutates it as you
wish.</p>
<p><strong>Note:</strong> This is actually how object orientation works for most languages. In
fact, Some languages, such as Go, Rust, and Python, don't even hide this. Their
method syntax is explicitly just syntactic sugar around this core feature. I
prefer this way!</p>
<p>For example, suppose you have a type <code>T</code> and a procedure <code>f</code>. If you want <code>f</code>
to mutate a variable of type <code>T</code>, have it accept <code>T*</code> as its first parameter.
That is <code>f(T*, ...)</code>.</p>
<p>Concretely,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Use Node from earlier
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  Node <span style="color:#ff79c6">*</span>head;
} List;

<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">addValue</span>(List <span style="color:#ff79c6">*</span>list, <span style="color:#8be9fd">int</span> val)
{
  Node <span style="color:#ff79c6">*</span>n <span style="color:#ff79c6">=</span> (Node <span style="color:#ff79c6">*</span>)malloc( <span style="color:#ff79c6">sizeof</span>( Node ) );
  n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>value <span style="color:#ff79c6">=</span> val;
  n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next <span style="color:#ff79c6">=</span> list<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>head;
  list<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>head <span style="color:#ff79c6">=</span> n;
}
</code></pre></div><h2 id="memory-management-of-linked-structures">Memory Management of Linked Structures</h2>
<p>With linked structures, since we're doing dynamic allocation, you must be very
careful that you don't leave anything dangling.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Freeing a list iteratively
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">while</span> (head) {
  Node <span style="color:#ff79c6">*</span>next <span style="color:#ff79c6">=</span> head<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next;
  free(head);
  head <span style="color:#ff79c6">=</span> next;
}

<span style="color:#6272a4">// Freeing a list recursively
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> freeNode(Node <span style="color:#ff79c6">*</span>n) {
  <span style="color:#ff79c6">if</span> (n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next) {
    freeNode(n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next);
  }
  free(n);
}
</code></pre></div><h2 id="adding-and-removing-in-linked-lists">Adding and Removing in Linked Lists</h2>
<p>In Java, we had to do the really annoying special cases for removing at the
front. However, because C allows us to use pointers more easily, we can get rid
of that special case by &ldquo;taking a step back&rdquo; and using a pointer the current
node we're on. We can then just mutate the thing we're pointing to.</p>
<p>You already know this and there's a great Computerphile video about it, so I
won't talk to much about it.</p>
<p><a href="https://www.youtube.com/watch?v=t5NszbIerYc">https://www.youtube.com/watch?v=t5NszbIerYc</a></p>
<h1 id="advanced-object-orientation">Advanced Object Orientation</h1>
<p>OOP in C is difficult, hard to read, hard to maintain, and overall not
idiomatic. However, for educational purposes, it is good to see how object
orientation can be / is done at a low level. We'll only talk about
inheritance, constructors, destructors, methods, and single dispatch.</p>
<p>Inheritance is the hardest of these.</p>
<h2 id="inheritance">Inheritance</h2>
<p>For inheritance, C's type system actively fights us. To make it work, we can do
multiple things. We can either have our subtyped struct have an instance of the
superclass struct as the first element (bad) or we could have our subtype
struct declare the same fields in the same order (worse).</p>
<p>Here, we'll only cover how to do single inheritance because multiple
inheritance is very difficult because you need to do address manipulation.</p>
<p>For the safe-ish method, the way you use the subtype is by casting it to the
supertype. Since C will put the first field at the start of the struct, when
you cast it you still have a valid address. This also means you can upcast in
the future as long as you're using pointers and not passing things by value.</p>
<p>For the unsafe method, the way you use the subtype is by casting it to the
supertype and hope that the you remembered to declare the fields in the correct
order and the compiler left them in the same order. Otherwise its the same.</p>
<h3 id="safe-subtyping">Safe Subtyping</h3>
<p>This is not the method we were taught in class, but it is type safe and
portable.</p>
<p>You could use callbacks (<code>callback.h</code>) to mimic method syntax at runtime. This
is less performant because you're doing it at runtime rather than compile time.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">struct</span> Animal {
  <span style="color:#6272a4">// Not abstract
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>name;
  <span style="color:#6272a4">// Abstract
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>sayHello)();
};

<span style="color:#ff79c6">struct</span> Animal <span style="color:#ff79c6">*</span><span style="color:#50fa7b">makeAnimal</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>name, <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">*</span>sayHello)()) {
  <span style="color:#ff79c6">struct</span> Animal <span style="color:#ff79c6">*</span>this <span style="color:#ff79c6">=</span> malloc(<span style="color:#ff79c6">sizeof</span>(Animal));
  this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>name <span style="color:#ff79c6">=</span> malloc((strlen(name) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">*</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#8be9fd">char</span>));
  strcpy(this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>name, name);
  this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>sayHello <span style="color:#ff79c6">=</span> sayHello;
  <span style="color:#ff79c6">return</span> this;
}

<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">freeAnimal</span>(<span style="color:#ff79c6">struct</span> Animal <span style="color:#ff79c6">*</span>this) {
  free(this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>name);
  free(this);
}

<span style="color:#ff79c6">struct</span> Dog {
  <span style="color:#ff79c6">struct</span> Animal <span style="color:#ff79c6">*</span>super;
}

<span style="color:#8be9fd">void</span> sayHelloDog(<span style="color:#ff79c6">struct</span> Dog <span style="color:#ff79c6">*</span>this) {
  printf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Bark! I&#39;m %s</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>super<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>name);
}

<span style="color:#ff79c6">struct</span> Dog <span style="color:#ff79c6">*</span>makeDog(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>name) {
  <span style="color:#ff79c6">struct</span> Dog <span style="color:#ff79c6">*</span>this <span style="color:#ff79c6">=</span> malloc(<span style="color:#ff79c6">sizeof</span>(Dog));
  <span style="color:#6272a4">// I&#39;m not 100% this works
</span><span style="color:#6272a4"></span>  this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>super <span style="color:#ff79c6">=</span> makeAnimal(name, alloc_callback(sayHelloDog, this));
  <span style="color:#ff79c6">return</span> this;
}

<span style="color:#8be9fd">void</span> freeDog(<span style="color:#ff79c6">struct</span> Dog <span style="color:#ff79c6">*</span>this) {
  free_callback(this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>sayHello);
  freeAnimal(this<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>super);
  free(this);
}
</code></pre></div><h2 id="constructors">Constructors</h2>
<p>Constructors are just procedures which dynamically</p>
<h1 id="handling-binary-data">Handling Binary Data</h1>
<p>Sadly, C99 has no way of reading in binary, printing out binary, or writing
binary literals.</p>
<h2 id="littlebig-endianness">Little/Big Endianness</h2>
<p>Differ architectures use differ byte orders for memory. This is because
computer engineers disagree on which is better, because there's not much of a
difference.</p>
<p><strong>Little endian</strong> machines put the least significant byte first. <strong>Big endian</strong>
machines put the most significant byte first; this is the way people normally
write it.</p>
<pre><code class="language-nohighlight" data-lang="nohighlight">int a = 3;
// Little Endian: 03 00 00 00
// Big Endian: 00 00 00 03
</code></pre><h2 id="binarybitwise-operators">Binary/Bitwise Operators</h2>
<p>In C, there are many operators that operate on bits. All of the binary
operators have equivalent assignment operators as you'd expect.</p>
<ul>
<li>Bitwise OR <code>x | y</code>: <code>0b10 | 0b01</code> is <code>0b11</code>.
<ul>
<li>Logical OR <code>||</code>.</li>
</ul>
</li>
<li>Bitwise AND <code>x &amp; y</code>: <code>0b10 &amp; 0b01</code> is <code>0b00</code>.
<ul>
<li>Logical AND <code>&amp;&amp;</code>.</li>
</ul>
</li>
<li>Bitwise NOT <code>~x</code>: <code>~0b10</code> is <code>0b01</code>.
<ul>
<li>Logical NOT <code>!</code>.</li>
</ul>
</li>
<li>Bitwise XOR <code>^x</code>: <code>0b110 ^ 0b100</code> is <code>0b010</code>.</li>
<li>Left Shift <code>x &lt;&lt; n</code>: Shifts the bits left by <code>n</code>, putting 0s in for the
&ldquo;walk off&rdquo;. <code>0b110 &lt;&lt; 1</code> is <code>0b100</code>.</li>
<li>Right Logical Shift <code>x &gt;&gt; n</code>: Shifts the bits right by <code>n</code>, putting 0s in for
the &ldquo;walk off&rdquo;. <code>0b011 &gt;&gt; 1</code> is <code>0b001</code>. Applies only to unsigned integers.</li>
<li>Right Arithmetic Shift <code>x &gt;&gt; n</code>: Same as right logical shift, except that the
&ldquo;walk off&rdquo; (on the left) is replaced with the sign bit. Applies only to
signed integers.</li>
</ul>
<dl>
<dt><code>0x1A &lt;&lt; 5</code></dt>
<dd><img src="left_shift.png" alt="0x1A << 5"></dd>
</dl>
<h2 id="bit-masking">Bit Masking</h2>
<p>Sometimes, we only care about certain bits. To get at these bits, we apply a
<strong>mask</strong>. A mask is just a number with specific bits flipped based off of what
you care about.</p>
<p>By ANDing the mask with the bits of interest, we keep only the bits that were
<code>1</code> in the original bits, making everything else <code>0</code>. This is called clearing
selected bits.</p>
<pre><code class="language-nohighlight" data-lang="nohighlight">// Clear bits 0 and 2
bits = 0b0110
mask = 0b1010
bits &amp; mask // 0b0010
</code></pre><p>By ORing the mask with the bits of interest, we keep only the bits that were
<code>0</code> in the original bits, making everything else <code>1</code>. This is called setting
selected bits.</p>
<pre><code class="language-nohighlight" data-lang="nohighlight">// Set bits 3 and 1
bits = 0b0110
mask = 0b1010
bits | mask // 0b1110
</code></pre><p>By XORing the mask with the bits of interest, we invert all the bits of
interest.</p>
<pre><code class="language-nohighlight" data-lang="nohighlight">// Invert bits 3 and 1
bits = 0b0110
mask = 0b1010
bits ^ mask // 0b1100
</code></pre><p>We can copy bit ranges by creating a mask of 1s with that range. We then AND
the source with the mask, AND the destination with the inverse of the mask, and
then OR those together.</p>
<dl>
<dt>Copying Bits</dt>
<dd><img src="copy_bits.png" alt="Copying Bits"></dd>
</dl>
<h2 id="bit-fields--packing">Bit Fields / Packing</h2>
<p>We can pack multiple smaller integers inside of a large integer by using masks
and bit shifting for modification and access. This allows for less memory use
at the cost of runtime (normally), since memory access that isn't along address
boundaries is less efficient on most CPUs.</p>
<p><a href="integer_packing.png">Integer Packing</a></p>
<p>You <em>really</em> shouldn't do this by hand if you do it at all. It's very easy to
make mistakes and it makes simple operations much more tedious.</p>
<p>If you're going to do this, we can make the compiler handle this by using bit
fields in structs. This makes the compiler handle all the shifting nonsense
required for field access and modification. It also handles when the number of
bit fields is longer than a single integer.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">short</span> red;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">short</span> green;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> blue;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> alpha;
} RegularColor;
<span style="color:#ff79c6">sizeof</span>(RegularColor); <span style="color:#6272a4">// 6
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">short</span> <span style="color:#8be9fd;font-style:italic">red</span> : <span style="color:#bd93f9">9</span>;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">short</span> <span style="color:#8be9fd;font-style:italic">green</span> : <span style="color:#bd93f9">9</span>;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#8be9fd;font-style:italic">blue</span> : <span style="color:#bd93f9">6</span>;
  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">char</span> <span style="color:#8be9fd;font-style:italic">alpha</span> : <span style="color:#bd93f9">6</span>;
} PackedColor;
<span style="color:#ff79c6">sizeof</span>(PackedColor); <span style="color:#6272a4">// 4
</span></code></pre></div><p>In general, these act exactly like normal fields. However, you cannot access
the address of the values, since they may not line up along address boundaries.</p>
<p><strong>Note:</strong> This is generally a bad idea and unnecessary on most modern systems,
since memory is cheap and its not very portable.</p>
<h2 id="2s-complement">2's Complement</h2>
<p>There's a fantastic <a href="https://www.youtube.com/watch?v=PS5p9caXS4U">!video</a> about
this. This explains 2's complement in decimal.</p>
<p>We normally use 2's complement, rather than 1's complement. This is because 1's
complement has a complicated &ldquo;end around borrow&rdquo; concept and a negative 0.</p>
<h1 id="object-oriented--component-design">Object Oriented / Component Design</h1>
<p>Changing header files is expensive because that requires recompiling the client
code and the library code. If we just change the library file, then we only
need to recompile the library code, which is faster.</p>
<p>For that reason, you want your header file to be as minimal as possible, only
making a library promise without exposing unnecessary implementation details.
There are a few ways to do this.</p>
<h2 id="abstracthidden-object">Abstract/Hidden Object</h2>
<p>We completely hide the object in question. The library maintains a static
singleton instance that isn't exposed in the header. The client can only
interact with this library code using procedures which interact with this
singleton instance behind the scenes. This is like project 3's wordlist!</p>
<p>This is generally <strong>okay</strong>, but it only allows us to have a single instance, so
it's very <strong>inflexible</strong>.</p>
<h2 id="incomplete-type--abstract-data-type">Incomplete Type / Abstract Data Type</h2>
<p>In the header file, we can declare that certain types/structs exist without
providing any fields on them. This means that clients can know that the library
provides such objects, but can't see any of their fields. In other words, these
objects are <strong>opaque</strong> to the client.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Incomplete types in header
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> Node Node;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Specific implementations in source
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> Node {
  <span style="color:#6272a4">// Here we&#39;re storing any generic data using a void pointer and a size
</span><span style="color:#6272a4"></span>  size_t size;
  <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>data;
  <span style="color:#ff79c6">struct</span> Node <span style="color:#ff79c6">*</span>next;
}
</code></pre></div><p>This is a lot like how Java and other traditional object oriented languages
work. However, they make it easier to use procedures that mutate the object by
using method notation, which attaches the procedure to the namespace of a
specific object. They also do a bunch of fancy single dispatch, polymorphism,
inheritance, and all that jazz.</p>
<p><strong>Note:</strong> This is an excellent trade off because it doesn't make either the
library or the client code more complicated, but it does make the library
significantly more flexible.</p>
<h3 id="generic-abstract-data-types">Generic Abstract Data Types</h3>
<p>Many times, we want a certain object to work with an entire family of objects.
(You want containers to work with any contained data.) C has the garbage, OG
way of doing this. To do this in C, you store a raw pointer and the number of
bytes associated with that piece of data. Then, client code must provide the
type either through function pointers that manipulate that data or using
casting whenever they want to pull something out of the object.</p>
<p>Here's a complete example that is a set implemented using an unordered linked
list.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&#34;set.h&#34;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>
<span style="color:#6272a4">// An inner component of our actual data type, Set
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Node {
  <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>val;
  <span style="color:#ff79c6">struct</span> Node <span style="color:#ff79c6">*</span>next;
};

<span style="color:#6272a4">// This is our actual data type this file deals with
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> SetStruct {
  <span style="color:#6272a4">// I can store any data, but I must know their size and how to compare the
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// data
</span><span style="color:#6272a4"></span>  size_t vsize;
  <span style="color:#8be9fd">bool</span> (<span style="color:#ff79c6">*</span>same)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span>v1, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span>v2);
  <span style="color:#ff79c6">struct</span> Node <span style="color:#ff79c6">*</span>head;
} Set;

Set <span style="color:#ff79c6">*</span><span style="color:#50fa7b">makeSet</span>(size_t vsize, <span style="color:#8be9fd">bool</span> (<span style="color:#ff79c6">*</span>same)(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span>v1, <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span>v2)) {
  Set <span style="color:#ff79c6">*</span>s <span style="color:#ff79c6">=</span> malloc(<span style="color:#ff79c6">sizeof</span>(Set)) ;
  s<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>head <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
  s<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>vsize <span style="color:#ff79c6">=</span> vsize;
  s<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>same <span style="color:#ff79c6">=</span> same;
  <span style="color:#ff79c6">return</span> s;
}
</code></pre></div><p><strong>Note:</strong> This makes both the library and the client code more complicated with
the benefit that it makes the library more flexible. This is generally seen as
a reasonable fair trade off as it doesn't make the client code significantly
more complicated, although it does make the library code significantly more
complicated.</p>
<h1 id="security--safety">Security &amp; Safety</h1>
<p>C has no training wheels. This makes it very powerful and efficient. However,
it also makes it easy to introduce <strong>bugs</strong> and <strong>security exploits</strong>.</p>
<h2 id="resource-leak">Resource Leak</h2>
<p>If you <code>malloc</code> something and return it in one path but not another, make sure
that you <code>free</code> it in the other path.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">/**
</span><span style="color:#6272a4">  Read an entire block of data from fp.
</span><span style="color:#6272a4">  @return Pointer to the block on success, or NULL on failure
</span><span style="color:#6272a4">*/</span>
<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span><span style="color:#50fa7b">getBlock</span>( FILE <span style="color:#ff79c6">*</span>fp ) {
  <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buf <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)malloc( BLOCK_SZ );
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>buf) {
    <span style="color:#6272a4">// Don&#39;t need to friend here.
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
  }
  <span style="color:#ff79c6">if</span> (fread( buf, <span style="color:#bd93f9">1</span>, BLOCK_SZ, fp ) <span style="color:#ff79c6">!</span><span style="color:#ff79c6">=</span> BLOCK_SZ ) {
    free(buf); <span style="color:#6272a4">// MAKE SURE TO FREE HERE!!!
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
  }
  <span style="color:#ff79c6">return</span> buf;
}
</code></pre></div><p>Likewise with file pointers.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#8be9fd">bool</span> <span style="color:#50fa7b">getFile</span>( <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>name, <span style="color:#8be9fd">int</span> cap, <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buffer ) {
  FILE <span style="color:#ff79c6">*</span>fp <span style="color:#ff79c6">=</span> fopen( name, “r” );
  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>fp ) {
    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
  }
  <span style="color:#8be9fd">int</span> len <span style="color:#ff79c6">=</span> fread( buffer, <span style="color:#bd93f9">1</span>, cap, fp );
  fclose(fp); <span style="color:#6272a4">// MAKE SURE NOT TO FORGET HERE
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">return</span> len <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>;
}
</code></pre></div><h2 id="input-validation">Input Validation</h2>
<p>When you do input validation, it's better to <strong>whitelist</strong> rather than
<strong>blacklist</strong>. Also, should you try to avoid taking in user input and pasting
that into some sort of &ldquo;eval&rdquo; function.</p>
<p>The best way to validate inputs is by using an open-source library that
validates and escapes things <strong>immediately</strong>.</p>
<p>C has a <code>int system(const char*)</code> procedure, that allows us to just run the
given string as if it were a shell command, and returns its return code.
You should <strong>never use this</strong> because it's slow and insecure. If you use it,
make sure to <strong>completely</strong> and <strong>totally</strong> validate all input.</p>
<h2 id="failure-to-understand-the-system">Failure to Understand the System</h2>
<h2 id="buffer-overflow">Buffer Overflow</h2>
<h1 id="encryption">Encryption</h1>
<h1 id="enums">Enums</h1>
<p>C enums allow us to avoid using preprocessor macros. This lets us have more
sophisticated scope rules.</p>
<p>C also automatically determines the optimal integer type for the enum in terms
of size and speed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Simple enum
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">enum</span> Color { RED, GREEN, BLUE };
<span style="color:#ff79c6">enum</span> Color c <span style="color:#ff79c6">=</span> RED;

<span style="color:#6272a4">// Enum with specified values
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">enum</span> Mood {
  HAPPY <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>,
  AFRAID,
  BORED <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>,
  BLUE,
  GLAD,
};
<span style="color:#ff79c6">enum</span> Mood m <span style="color:#ff79c6">=</span> HAPPY;
</code></pre></div><p>There are a few limits on enums. You can't have two enums in the same scope
with the same value. Also, enums are literally just integers, so you can add
them, use them as booleans, increment them, and all that nonsense. They are
also printed as integers.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ff79c6">enum</span> Color { red, green, blue };
<span style="color:#ff79c6">enum</span> Mood { happy, sad, blue }; <span style="color:#6272a4">// THIS WON&#39;T WORK
</span><span style="color:#6272a4"></span>
<span style="color:#ff79c6">enum</span> Mood m <span style="color:#ff79c6">=</span> happy;
m<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span>; <span style="color:#6272a4">// m == sad (probably)
</span></code></pre></div><h2 id="enum-hack">Enum Hack</h2>
<p>Since enums are constant expressions and respect scope, we can use them as
compile time constants if we're using a common name (e.g. <code>SIZE</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6272a4">// Okay, but doesn&#39;t respect scope
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">define SIZE 100</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span><span style="color:#ff79c6">struct</span> Contact {
  <span style="color:#8be9fd">char</span> name[ SIZE ];
  <span style="color:#8be9fd">char</span> email[ SIZE ];
};

<span style="color:#6272a4">// Does respect scope, but a little hacky
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">struct</span> Contact {
  <span style="color:#ff79c6">enum</span> { SIZE <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">100</span> };
  <span style="color:#8be9fd">char</span> name[ SIZE ];
  <span style="color:#8be9fd">char</span> email[ SIZE ];
}
</code></pre></div><h1 id="unions">Unions</h1>
<h1 id="odd-keywords">Odd Keywords</h1>
<p>C normally makes optimizations such as storing values to the register and not
rereading memory. This is good because it's more performant. However, sometimes
(e.g. when doing concurrency), that value might have changed. We use the
<code>volatile</code> keyword to tell C to not do optimizations for this value.</p>
<h1 id="testing--profiling">Testing &amp; Profiling</h1>
<p>Profiling is the process of figuring out what your program is spending its time
and resources doing. You know what testing and coverage is.</p>
<h2 id="test-coverage">Test Coverage</h2>
<p>In this class, we use <code>gcov</code> (GNU Coverage tool) to get test coverage. This
requires we enable some features on compilation. <code>-fprofile-arcs</code> tracks branch
coverage. <code>-ftest-coverage</code> tracks statement coverage.</p>
<h2 id="profiling">Profiling</h2>
<p>In this class, we use <code>gprof</code> (GNU Profiler tool) to profile things.</p>
<h2 id="diy-optimizations">DIY Optimizations</h2>
<p>Generally, you should not do these DIY code optimizations if they hurt
readability. Most compilers are optimizing and will do this for you. A few
exceptions are inlining simple functions, passing by <code>const</code> reference, and
putting the most common conditions first.</p>
<h1 id="c">C++</h1>
<p>We'll learning C++11. It has the following features.</p>
<ul>
<li>Namespaces</li>
<li>Classes and objects.</li>
<li>Destructors.</li>
<li>Operate overloading.</li>
<li>Move Semantics: How to safely describe memory changes / ownership.</li>
<li><code>constexpr</code>: Evaluate arbitrary expressions at compile time.</li>
<li>Range Based For Loops: Iterators.</li>
<li>Lambda Expressions.</li>
<li>Lambda Captures: Strongly documented closures.</li>
<li><code>nullptr</code>: Essentially renamed <code>NULL</code>.</li>
<li>Templates: Allows you to define how to build a function given some arbitrary
compile time values. Created for compile time generics.
<ul>
<li>Can be used for <em>many</em> other things.</li>
</ul>
</li>
<li>C backwards compatibility.</li>
</ul>
<p>Here's an overview of the terminology that differs from Java's terminology.</p>
<ul>
<li>Base Class: Super(most) class.</li>
<li>Derived Class: Subclass.</li>
</ul>
<h2 id="hello-world">Hello World!</h2>
<p>Notice how we use the bitshift operators? That's standard in C++! We overload
the stream with nice-looking operators to give use new, easier syntax.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// So we get access to std::cout
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&lt;iostream&gt;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>
<span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>() {
  <span style="color:#6272a4">// Put the folowing string to the std::cout stream
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// std::cout is buffered stdout
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Hello, World!</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>;

  <span style="color:#6272a4">// Alternatively, use std::endl
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// std::endl is the platform specific line terminator and std::flush
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// std::flush tells the buffered output to flush
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>count <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Hello, World!</span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>endl;
  <span style="color:#6272a4">// Write newline manually and then flush
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>count <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Hello, World!</span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#39;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>flush;

  <span style="color:#6272a4">// Generally, you shouldn&#39;t use std::endl or std::flush because generally the
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// OS knows better when it should flush the buffer than you.
</span><span style="color:#6272a4"></span>}
</code></pre></div><h2 id="namespaces">Namespaces</h2>
<p>Namespace extensions</p>
<p>C++ defaults to searching in the current namespace (including any namespaces
you're <code>using</code>). If it can't find the name you're looking for, then that's an
error.</p>
<p>C++ has the scope resolution operation: <code>::</code>. You put this after a namespace to
get a name within the namespace.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">int</span> val <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>;
<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">f</span>() {
  <span style="color:#6272a4">// Prints 3
</span><span style="color:#6272a4"></span>  std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> val;
}

<span style="color:#ff79c6">namespace</span> MyNamespace {
  <span style="color:#8be9fd">int</span> val <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">10</span>;
  <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">f</span>() {
    std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">val: </span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> val <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>;
    std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">global: </span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>val <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>;
  }
}

<span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>
<span style="color:#6272a4">// Call global f
</span><span style="color:#6272a4"></span>f();
<span style="color:#6272a4">// Call f in MyNamespace
</span><span style="color:#6272a4"></span>MyNamespace<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>f();
</code></pre></div><h2 id="using-c-libraries">Using C Libraries</h2>
<p>We can use C libraries easily in C++. The only difference is that they are in
the <code>std</code> namespace and their header files get a makeover. Remove the <code>.h</code> and
prepend the name with a <code>c</code>. We use namespaces because they're nice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// Import stdio.h from C
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&lt;cstdio&gt;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>
<span style="color:#6272a4">// Like a * import from other languages. Import everything from std namespace
</span><span style="color:#6272a4"></span><span style="color:#6272a4">// into our namespace. Use with care! (Or not at all.)
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">using</span> <span style="color:#ff79c6">namespace</span> std;

<span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>() {
  printf(<span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Hello, within C!</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
}
</code></pre></div><h2 id="file-io-1">File IO</h2>
<p>File IO is done using input streams (<code>istream</code>s) and output streams
(<code>ostream</code>s). Specifically, it's done with a specialization of both of these
streams, <code>fstream</code>s.</p>
<h2 id="raii-resource-acquisition-is-initialization">RAII (Resource Acquisition Is Initialization)</h2>
<p>RAII is a standard idiom in programming. It essentially says that all resources
should have a constructor and destructor. The constructor is called at resource
acquisition time. C++ itself automatically calls the destructor whenever your
object goes out of scope. It guarantees that it calls this in all possible
paths, even if your program crashes. You <em>can</em> manually call the destructor.</p>
<p>This is sometimes called SBRM (Scope Based Resource Management). It's the same
thing.</p>
<p>This pattern means we don't need to worry about a lot of resources. For
example, we don't <em>need</em> to close files when we're done with them. (Although
it's not a bad idea.)</p>
<h2 id="references-and-move-semantics">References and Move Semantics</h2>
<p>References are a safe abstraction around pointers that allows for additional
optimizations, because we're guaranteed by the compiler the pointers are known
to be identical.</p>
<p>Syntactically, we treat it as if we had the value itself. Essentially, it's
just an <em>alias</em> for the other value. This means we can also <em>assign to returned
references</em>, which is really cool.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// Takes a reference to a and b
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">swap</span>(<span style="color:#8be9fd">int</span> <span style="color:#ff79c6">&amp;</span>a, <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">&amp;</span>b) {
  <span style="color:#6272a4">// notice how we&#39;re not dereferencing. It calls int&#39;s copy constructor
</span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> tmp <span style="color:#ff79c6">=</span> a;
  a <span style="color:#ff79c6">=</span> b;
  b <span style="color:#ff79c6">=</span> temp;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">&amp;</span>a <span style="color:#ff79c6">=</span> some[complicated]<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>object.thing;
<span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> a <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>endl;
a <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">12</span>;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">int</span> <span style="color:#ff79c6">&amp;</span>lookup( <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>name ) {
  ...;
}

<span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>
<span style="color:#6272a4">// Assigning from reference
</span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> x <span style="color:#ff79c6">=</span> lookup( <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">mary</span><span style="color:#f1fa8c">&#34;</span> );
<span style="color:#6272a4">// Assigning to reference
</span><span style="color:#6272a4"></span>lookup( <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">bob</span><span style="color:#f1fa8c">&#34;</span> ) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">35</span>;

<span style="color:#6272a4">// Notice how there&#39;s no pointer syntax!
</span></code></pre></div><h2 id="templates">Templates</h2>
<p>We want to define our functions to work with abstract data. How do we do that?
In C++, we use templates!</p>
<p>Templates are compile time feature, where the compiler figures out all the
different versions of your template you call and compile them all as separate
functions.</p>
<h2 id="default-parameters">Default Parameters</h2>
<p>The syntax is almost exactly what you think it would be!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">repeat</span>(<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">*</span>str <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Good Evening</span><span style="color:#f1fa8c">&#34;</span>, <span style="color:#8be9fd">int</span> count <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">10</span>) {
  <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> count; i<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span>) {
    std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> str;
  }
}
</code></pre></div><h2 id="string-class">String Class</h2>
<p>Strings are mutable character buffers wrapped in objects. You can treat them
like primitives and they use copy semantics.</p>
<p>They also have array indexing overloaded, so you can treat them like char
arrays!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">string a <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">123</span><span style="color:#f1fa8c">&#34;</span>;
string b <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">xyz</span><span style="color:#f1fa8c">&#34;</span>;
string c;
c <span style="color:#ff79c6">=</span> a; <span style="color:#6272a4">// copies a to c
</span><span style="color:#6272a4"></span>c <span style="color:#ff79c6">=</span> a <span style="color:#ff79c6">+</span> b; <span style="color:#6272a4">// makes c a copy of a and b concatenated
</span><span style="color:#6272a4"></span>
<span style="color:#6272a4">// Compares the contents of a and b
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> (a <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> b) {
  cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Hi!</span><span style="color:#f1fa8c">&#34;</span>;
}
</code></pre></div><h3 id="string-io">String IO</h3>
<p>You can use streams (as earlier), but there's also a few helpful functions.</p>
<ul>
<li><code>getline(istream &amp;is, string &amp;str)</code>: Reads a line from <code>is</code> into <code>str</code>,
dynamically resizing <code>str</code> as necessary.</li>
</ul>
<h3 id="string-methods">String Methods</h3>
<ul>
<li><code>string substr(int pos, int len)</code>: Create a substring of len characters,
starting at pos by copying the characters.</li>
<li><code>size_t find(string &amp;str)</code>: Return starting index of the first occurrence of
str. Returns <code>string::npos</code> if no matches are found.</li>
<li><code>insert(int pos, string &amp;str)</code>: Insert str at position pos, displacing all
characters on the right.</li>
<li><code>erase(int pos, int len)</code>: Remove len characters starting at pos, shifting
all characters on the right.</li>
<li><code>char *c_str()</code>: Return the underlying char array for the <code>string</code>.</li>
</ul>
<h2 id="standard-template-library-stl">Standard Template Library (STL)</h2>
<p>The standard template library in C++ is the standard library's collection
framework. It's pretty big, so we won't cover them all.</p>
<h3 id="vector">Vector</h3>
<p>Vector is the simplest and most used container. It is in the <code>&lt;vector&gt;</code> header.
It is like an <code>ArrayList</code> in Java, a resizable array of generic elements.</p>
<p>You can use the following to initialize vectors.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;</span> iList( <span style="color:#bd93f9">10</span> );
vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">short</span><span style="color:#ff79c6">&gt;</span> sList( <span style="color:#bd93f9">20</span>, <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span> );
</code></pre></div><p>Vectors have the traditional mutation methods</p>
<p>Vectors support deep copying, just use simple a assignment.</p>
<h3 id="iterators">Iterators</h3>
<p>C++11 has a for each loop.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// Value iteration. Generally lame.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> <span style="color:#8be9fd;font-style:italic">v</span> : container) {
  count <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> v <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
}
<span style="color:#6272a4">// Reference iteration. Only do if you need mutability.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd;font-style:italic">v</span> : container) {
  count <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> v <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
}
<span style="color:#6272a4">// Const reference iteration. Use most of the time.
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">for</span> (<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd;font-style:italic">v</span> : container) {
  count <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> v <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
}
</code></pre></div><h2 id="memory-management-1">Memory Management</h2>
<p>Like the <code>malloc</code> and <code>free</code> procedures in C, we have <code>new</code> and <code>delete</code> in
C++.</p>
<h2 id="classes-and-structs">Classes and Structs</h2>
<p>In C++, classes and structs are identical except that for classes, the default
access is private, structs, the default access is public. Generally, however,
we use structs just to be blobs of data and classes for, well, classes.</p>
<p>C++ has a lot of energy dedicated to making classes good. Here are a bunch of
<em>special member functions</em>.</p>
<h3 id="constructors-1">Constructors</h3>
<p>They are responsible to assigning values to the fields to the class. The memory
for the object is already allocated by the time it runs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Person</span> {
  string name;
  <span style="color:#8be9fd">int</span> age;

  <span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
  Person(string name, <span style="color:#8be9fd">int</span> age) {
    <span style="color:#6272a4">// Use the implicity this reference (generally preferred)
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">this</span><span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>name <span style="color:#ff79c6">=</span> name;
    <span style="color:#6272a4">// Use the scope resolution operator
</span><span style="color:#6272a4"></span>    Person<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>age <span style="color:#ff79c6">=</span> age;
  }

  ...;
};
</code></pre></div><h3 id="default-constructor">Default Constructor</h3>
<p>The default constructor is a parameterless constructor that gets call
automatically when you allocate the object. This is important to assign the
fields to their start / null values.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">SomeClass</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
  SomeClass() {
    std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Hi!</span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> std<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>endl;
  }
}

SomeClass c; <span style="color:#6272a4">// calls default constructor
</span><span style="color:#6272a4"></span>SomeClass <span style="color:#ff79c6">*</span>cp <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> SomeClass; <span style="color:#6272a4">// calls default constructor
</span><span style="color:#6272a4"></span>SomeClass c[<span style="color:#bd93f9">5</span>]; <span style="color:#6272a4">// calls default constructor 5 times
</span></code></pre></div><h3 id="copy-constructor">Copy Constructor</h3>
<p>The copy constructor is used whenever you pass an object by value (whether
passing it to a function or assigning it to something else).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">List</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
  <span style="color:#6272a4">// other is what you want to copy. This must be a reference because otherwise
</span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// you&#39;d have to call the copy constructor to call the copy constructor.
</span><span style="color:#6272a4"></span>  List(<span style="color:#ff79c6">const</span> List <span style="color:#ff79c6">&amp;</span>other) {
    Node <span style="color:#ff79c6">*</span><span style="color:#ff79c6">*</span>ptr <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>head;
    <span style="color:#ff79c6">for</span> ( Node <span style="color:#ff79c6">*</span>n <span style="color:#ff79c6">=</span> other.head; n; n <span style="color:#ff79c6">=</span> n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next ) {
      <span style="color:#ff79c6">*</span>ptr <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Node;
      (<span style="color:#ff79c6">*</span>ptr)<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>val <span style="color:#ff79c6">=</span> n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>val;
      ptr <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">&amp;</span>((<span style="color:#ff79c6">*</span>ptr)<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next);
    }
    <span style="color:#6272a4">// terminate the list
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">*</span>ptr <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
  }
};

<span style="color:#6272a4">// Example usage
</span><span style="color:#6272a4"></span>List alist;
alist.push(<span style="color:#bd93f9">2</span>);
<span style="color:#6272a4">// Calls copy constructor
</span><span style="color:#6272a4"></span>List blist <span style="color:#ff79c6">=</span> alist;
alist.push(<span style="color:#bd93f9">3</span>);
alist.size() <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>;
blist.size() <span style="color:#ff79c6">=</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>;
</code></pre></div><h3 id="destructor">Destructor</h3>
<p>Destructors are called automatically when the object goes out of scope
(allocated on the stack) or when <code>delete</code> is called manually. C++ will default
to having a destructor that does nothing. This is <strong>not</strong> okay for objects that
dynamically allocate things.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
</code></pre></div><h3 id="operator-overloading">Operator Overloading</h3>
<p>All operator's are overloaded by defining a <code>operatorSYMBOL</code> member function.
They only must accept a certain number of arguments, but their types are
returns are not mandated.</p>
<p>They can be member functions or not.</p>
<h3 id="suppressing-value-semantics-and-others">Suppressing Value Semantics (and others)</h3>
<p><strong>TODO:</strong></p>
<p>It uses <code>= delete</code> after declaring the method.</p>
<h3 id="friendship">Friendship</h3>
<p>If you want to access private elements of a class (or something) in a certain
function defined outside of the class, you must declare it a <code>friend</code>,
otherwise they cannot access the private elements.</p>
<p>In the following example, since we want <code>ostream</code> to be the left hand side, we
must declare the overloaded operator as a non-member function. Since this wants
to access a private member of <code>List</code>, this must be a friend.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">List</span> {
  <span style="color:#6272a4">// Allows this function&#39;s definition to access its private parts.
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">friend</span> ostream <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">operator</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span>( ostream <span style="color:#ff79c6">&amp;</span>output, <span style="color:#ff79c6">const</span> List <span style="color:#ff79c6">&amp;</span>lst );
};

<span style="color:#6272a4">// If you didn&#39;t declare this a friend earlier, then this could not access lst.head.
</span><span style="color:#6272a4"></span>ostream <span style="color:#ff79c6">&amp;</span><span style="color:#ff79c6">operator</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span>( ostream <span style="color:#ff79c6">&amp;</span>output, <span style="color:#ff79c6">const</span> List <span style="color:#ff79c6">&amp;</span>lst ) {
  <span style="color:#ff79c6">for</span> ( List<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>Node <span style="color:#ff79c6">*</span>n <span style="color:#ff79c6">=</span> lst.head; n; n <span style="color:#ff79c6">=</span> n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>next ) {
    output <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> n<span style="color:#ff79c6">-</span><span style="color:#ff79c6">&gt;</span>val <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c"> </span><span style="color:#f1fa8c">&#34;</span>;
  }
  <span style="color:#ff79c6">return</span> output;
}
</code></pre></div><h2 id="headers-in-c">Headers in C++</h2>
<p>In C++, it's a good idea to declare all public classes in a header file, for
the same reason we do in C. This does require we use a different syntax for
implementing because we have namespaces.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">List</span> {
  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">Node</span> {
    <span style="color:#8be9fd">int</span> val;
    Node <span style="color:#ff79c6">*</span>next;
  };
  Node <span style="color:#ff79c6">*</span>head;
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
  <span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> x; <span style="color:#6272a4">// It&#39;s not my job to declare this
</span><span style="color:#6272a4"></span>
  List();
  List( <span style="color:#ff79c6">const</span> List <span style="color:#ff79c6">&amp;</span> );
  <span style="color:#ff79c6">~</span>List();
  ...;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#6272a4">// list.c
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&lt;iostream&gt;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>
<span style="color:#ff79c6">#</span><span style="color:#ff79c6">include</span> <span style="color:#ff79c6">&#34;list.h&#34;</span><span style="color:#ff79c6">
</span><span style="color:#ff79c6"></span>
<span style="color:#ff79c6">using</span> <span style="color:#ff79c6">namespace</span> std;

<span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> List<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>x <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">5</span>;

List<span style="color:#ff79c6">:</span><span style="color:#ff79c6">:</span>List() {
  head <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
}

<span style="color:#6272a4">// Implementing copy constructor, destructor, etc.
</span></code></pre></div><h2 id="throwing">Throwing</h2>
<p>In C++, we can throw anything! We have the exact same <code>try-catch</code> system.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">f</span>(<span style="color:#8be9fd">int</span> val) {
  <span style="color:#ff79c6">if</span> (val <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>) {
    <span style="color:#ff79c6">throw</span> <span style="color:#bd93f9">42</span>;
  }
  <span style="color:#ff79c6">if</span> ( val <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">3</span> <span style="color:#ff79c6">!</span><span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span> ) {
    <span style="color:#ff79c6">throw</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">That value isn&#39;t divisible by 3</span><span style="color:#f1fa8c">&#34;</span>;
  }
  <span style="color:#ff79c6">return</span> val <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">3</span>;
}

<span style="color:#6272a4">// Calling code
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">try</span> {
  <span style="color:#8be9fd">int</span> result <span style="color:#ff79c6">=</span> f( val );
  cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> result <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
} <span style="color:#ff79c6">catch</span> ( <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>str ) {
  cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Error: </span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> str <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
} <span style="color:#ff79c6">catch</span> ( <span style="color:#8be9fd">int</span> code ) {
  cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">Internal Error: </span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> code <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
}
</code></pre></div><h2 id="inheritance-1">Inheritance</h2>
<p>We'll only cover <em>public</em> inheritance. You can look up private (and protected)
inheritance.</p>
<p>As you know, the main reason to do inheritance is for abstraction (not code
reuse!).</p>
<h3 id="virtual-methods">Virtual Methods</h3>
<p>Virtual functions are the way you tell the compiler you'd like to use <em>single
dispatch</em> for that function.</p>
<h3 id="const-methods">Const Methods</h3>
<p>Const methods are member functions that are not allowed to mutate the object.
You can only call const methods on const objects. You can call both const
methods and non-const methods on non-const objects.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">EmailContact</span> <span style="color:#ff79c6">:</span> <span style="color:#ff79c6">public</span> Contact {
  <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>email;
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
  ...;
  <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">print</span>() <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">override</span> {
    <span style="color:#6272a4">// Print our name and our email.
</span><span style="color:#6272a4"></span>    cout <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> getName() <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> <span style="color:#f1fa8c"></span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c"> </span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> email <span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">&lt;</span> endl;
  }
};
</code></pre></div>
    </div>

  </article>


</section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
